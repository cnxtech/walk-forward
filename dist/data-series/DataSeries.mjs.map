{"version":3,"sources":["../../src/data-series/DataSeries.mjs"],"names":["logger","ColumnConfig","convertObjectToMap","log","debug","DataSeries","Map","add","data","Error","addColumns","internalData","push","getDefaultColumnConfiguration","key","columns","has","set","value","JSON","stringify","length","headRow","head","get","itemCount","startIndex","len","result","slice","Math","max","reverse","tail"],"mappings":"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","sourcesContent":["import logger from '../logger/logger';\nimport ColumnConfig from './ColumnConfig';\nimport convertObjectToMap from './convertObjectToMap';\n\nconst log = logger('WalkForward:DataSeries');\nconst { debug } = log;\n\n/**\n* Stores multiple values for a given key. Key is e.g. a date, values 'open', 'close' etc.\n* Key must not be unique – as there may be be multiple keys that are equal (e.g. same date)\n*/\nexport default class DataSeries {\n\n\n\t/**\n\t* Holds the data series's data as objects with key: key, data: Map()\n\t* @private \n\t*/\n\tinternalData = [];\n\n\n\t/**\n\t * Holds column information. Key is the column's key, value the configuration. Configuration\n\t * may contain\n\t * - View information (for diagrams, tables …)\n\t * - Type information (Date etc., e.g. to format and read CSV)\n\t * - A description (if key is a Symbol; e.g. for CSV output)\n\t * @private\n\t */\n\tcolumns = new Map();\n\t\n\n\n\n\t/**\n\t* Adds one or multiple values for a given key. \n\t* @param {Map|object} data\t\tData to add, Maps are preferred\n\t*/\n\tadd(data) {\n\n\t\tlog.debug('Add data %o', data);\n\n\t\t// If an object (which is not a map) is passed, try to convert it to a Map\n\t\tif (typeof data === 'object' && !(data instanceof Map)) {\n\t\t\tdata = convertObjectToMap(data);\n\t\t}\n\n\t\t// Validate data parameter\n\t\tif (!data || !(data instanceof Map)) {\n\t\t\tthrow new Error(`DataSeries: Data passed to add method must be a Map,\n\t\t\t\tis ${ data }.`, );\n\t\t}\n\n\t\t// If column key is new, add it to this.columns\n\t\tthis.addColumns(data);\n\n\t\t// Clone data or original data is modified when set() is used which adds a new item to the\n\t\t// Map\n\t\tthis.internalData.push(new Map(data));\n\n\t}\n\n\n\t/**\n\t * Returns the default config for a column\n\t * @private\n\t * @return {object} \tColumn configuration\n\t */\n\tgetDefaultColumnConfiguration() {\n\t\treturn new ColumnConfig();\n\t}\n\n\t/**\n\t * Adds data to this.columns if key is not yet present\n\t * @private\n\t * @param {Map} data\t\tData (passed through this.add or this.set)\n\t */\n\taddColumns(data) {\n\t\tfor (const [key] of data) {\n\t\t\tif (!this.columns.has(key)) this.columns.set(key, this.getDefaultColumnConfiguration());\n\t\t}\t\t\n\t}\n\n\n\t/**\n\t* Prevents users from modifying data directly\n\t* @private\n\t*/\n\tset data(value) {\n\t\tthrow new Error(`DataSeries: Don't modify data directly, use add method.`);\n\t}\n\n\n\t/**\n\t* Returns the data added through add\n\t* @returns {object}\n\t*/\n\tget data() {\n\t\treturn this.internalData;\n\t}\n\n\n\t/**\n\t* Adds data (columns) to the head row. Is needed for external scripts to modify the\n\t* DataSeries and to add results of transformations.\n\t* @param {Map|object} data\t\t\tData to add to current row in the form of { colName: value }\n\t*\t\t\t\t\t\t\t\t\tor new Map([['col': 'value']]). Maps are preferred.\n\t*/\n\tset(data) {\n\n\t\t// If an object (which is not a map) is passed, try to convert it to a Map\n\t\tif (typeof data === 'object' && !(data instanceof Map)) {\n\t\t\tdata = convertObjectToMap(data);\n\t\t}\n\n\t\tif (!(data instanceof Map)) {\n\t\t\tthrow new Error(`DataSeries: Argument for set method must be a Map, is\n\t\t\t\t${JSON.stringify(data)}`);\n\t\t}\n\n\t\tif (!this.internalData.length) {\n\t\t\tthrow new Error(`DataSeries: Cannot set data on head row as there are no rows \n\t\t\t\tat all`);\n\t\t}\n\n\t\tconst headRow = this.head();\n\n\t\tfor (const [key, value] of data) {\n\t\t\t// Don't let user overwrite existing data; if we did, we'd have to implement an other\n\t\t\t// test to see if transformers were called.\n\t\t\tif (headRow.has(key)) {\n\t\t\t\tthrow new Error(`DataSeries: Existing values cannot be overwritten by using the\n\t\t\t\t\tset method; tried to overwrite %o with %o, is already %o`, key, value,\n\t\t\t\t\theadRow.get(key));\n\t\t\t}\n\t\t\tdebug('Set col %o to %o', key, value);\n\t\t\theadRow.set(key, value);\n\t\t}\n\n\t\t// Only add columns after testing data and throwig errors\n\t\tthis.addColumns(data);\n\n\t}\n\n\n\t/**\n\t* Returns the latest few rows\n\t* @param {integer} itemCount\tAmount of items to return, defaults to 1\n\t* @paramm {integer} startIndex\tIndex to start (from the end), defaults to 0\n\t* @returns {array|object}\t\tArray of objects (if param intemCount > 1), else a single \n\t*\t\t\t\t\t\t\t\tobject (wich corresponds to the data field of internalData; key\n\t*\t\t\t\t\t\t\t\tis ignored)\n\t*/\n\thead(itemCount = 1, startIndex = 0) {\n\t\tconst len = this.internalData.length;\n\t\tconst result = this.internalData\n\t\t\t// Don't use negative numbers, they will slice from the end!\n\t\t\t.slice(Math.max(0, len - itemCount - startIndex), Math.max(0, len - startIndex))\n\t\t\t.reverse();\n\t\treturn itemCount === 1 ? result[0] : result;\n\t}\n\n\n\t/**\n\t* Returns the first few rows\n\t* @param {integer} itemCount\tAmount of items to return, defaults to 1\n\t* @paramm {integer} startIndex\tIndex to start, defaults to 0\n\t* @returns {array|object}\t\tArray of objects (if param intemCount > 1), else a single \n\t*\t\t\t\t\t\t\t\tobject (wich corresponds to the data field of internalData; key\n\t*\t\t\t\t\t\t\t\tis ignored)\n\t*/\n\ttail(itemCount = 1, startIndex = 0) {\n\t\tconst result = this.internalData\n\t\t\t.slice(startIndex, itemCount + startIndex);\n\t\treturn itemCount === 1 ? result[0] : result;\n\t}\n\n\n\t/**\n\t * Creates a new DataSeries from an existing data set (source). If a transformer is passed, \n\t * it's applied to the data passed.\n\t * @param  {DataSeries} source      \t\tAn existing DataSeries\n\t * @param  {function} transformer\t\t\tFunction that takes 3 arguments: column, row and \n\t *                                \t \t\tcell. Must return the new cell value.\n\t * @param {function} columnKeyTransformer \tFunction that takes a single argument (column key)\n\t *                                         \tand returns new column key\n\t * @return {DataSeries}             \t\tCopied and transformed DataSeries\n\t */\n\t/*static from(source, transformer, columnKeyTransformer) {\n\n\t\tif (transformer !== undefined && typeof transformer !== 'function') {\n\t\t\tthrow new Error(`DataSeries: Second argument of transformer must be a function or\n\t\t\t\tnothing at all.`);\n\t\t}\n\n\t\tif (source instanceof DataSeries) {\n\t\t\treturn cloneDataSeries(DataSeries, source, transformer, columnKeyTransformer);\n\t\t}\n\t\telse {\n\t\t\tthrow new Error(`DataSeries: Call static from method with an existing DataSeries;\n\t\t\t\tother sources are not yet supported.`);\n\t\t}\n\n\t}*/\n\n}\n\n"],"file":"DataSeries.mjs"}