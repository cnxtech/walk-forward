{"version":3,"sources":["../../src/backtest-exporter/BacktestExporter.mjs"],"names":["path","fs","logger","DataSeriesExporter","ViewableDataSeries","TransformableDataSeries","DataSeries","Instrument","exportToCsv","HighChartsExporter","debug","BacktestExporter","Map","export","instances","directory","Error","folderName","createBaseFolder","join","createDirectoryIfNotExists","exportInstances","exportAllAccounts","exportAllPerformanceIndicators","results","currentRun","firstRow","size","push","params","paramNames","paramSet","Array","from","values","length","keys","forEach","item","index","row","instanceParam","firstInstance","undefined","performanceIndicatorNames","performanceResults","performanceIndicatorName","instance","get","folderContent","readdirSync","content","parsed","parseInt","Number","isNaN","exportInstance","basePath","allAccountsData","runNumber","currentAccount","exportedAccounts","data","set","allAccounts","date","add","exporter","chartExporter","number","instancePath","accountData","exportAccount","accounts","exportInstancePositions","positions","instrument","instruments","exportInstrument","cleanPositions","rowMap","columnKey","columns","has","name","AccountTotalTransformer","next","reduce","prev","accountsWithTotal","addTransformer","col","instrumentPath","instrumentsSubDirectory","instrumentClone","viewConfig","PositionTransformer","position","find","positionRow","getTime","instrumentPosition","getChartConfig","chart","height","title","text","series","type","destination","directoryPath","Promise","resolve","reject","access","constants","F_OK","err","mkdir","mkdirErr"],"mappings":"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","sourcesContent":["import path from 'path';\nimport fs from 'fs';\nimport logger from '../logger/logger';\nimport DataSeriesExporter from '../data-series-exporter/DataSeriesExporter';\nimport ViewableDataSeries from '../data-series/ViewableDataSeries';\nimport TransformableDataSeries from '../data-series/TransformableDataSeries';\nimport DataSeries from '../data-series/DataSeries';\nimport Instrument from '../instrument/Instrument';\nimport exportToCsv from '../export-to-csv/exportToCsv';\nimport HighChartsExporter from './HighChartsExporter';\n\nconst { debug } = logger('WalkForward:BacktestExporter');\n\n\nexport default class BacktestExporter {\n\n    instrumentsSubDirectory = 'instruments';\n\n    /**\n     * Data series for all exported accounts; exported accounts contain a total (which is missing\n     * in original accounts). Needed to create list with *all* accounts (to compare performance).\n     */\n    exportedAccounts = new Map();\n\n    /**\n     * Exports data of a backtest\n     * @param  {Map} instances          Key: parameter set, value: BacktestInstance\n     * @param  {string} directory       Base path for export\n     */\n    async export(instances, directory) {\n        if (!instances || !(instances instanceof Map)) {\n            throw new Error(`BacktestExporter: instances must be a Map of BacktestInstances, is ${instances}.`);\n        }\n        if (!directory || typeof directory !== 'string') {\n            throw new Error(`BacktestExporter: directory passed must be a string, is ${directory}.`);\n        }\n        this.instances = instances;\n\n        const folderName = this.createBaseFolder(directory);\n        this.directory = path.join(directory, `${folderName}`);\n\n        // Create base directory\n        await this.createDirectoryIfNotExists(this.directory);\n\n        await this.exportInstances();\n\n        // Export an overview over all accounts; do this *after* we have exported single instance\n        // because only now we will have accounts available\n        await this.exportAllAccounts(this.directory);\n\n        await this.exportAllPerformanceIndicators(instances, this.directory);\n\n    }\n\n    /**\n     * Exports performance indicators for all instances in a table (to compare how parameterSets\n     * performed), also exports parameter set itself\n     * @param  {Map} instances              See constructor\n     * @param  {string} directory\n     */\n    async exportAllPerformanceIndicators(instances, directory) {\n\n        // Table contains:\n        // First row: Number of run\n        // Following rows: Optimized parameterr sets (1 row per parameter))\n        // Following rows: Performance indicators\n        // First col: Title of row\n        // Subsequent cols: Data (col 1 per parameter set)\n        const results = [];\n\n        // First row: 'Row', then all the runs\n        let currentRun = 0;\n        const firstRow = ['Run'];\n        while (currentRun < instances.size) {\n            currentRun += 1;\n            // Export performance indicator results\n            // Re-format performance results; row 0: all names, row 1: all values\n            firstRow.push(currentRun);\n        }\n        results.push(firstRow);\n\n        // Add parameters as rows\n        const params = [];\n        let paramNames = [];\n        for (const [paramSet] of instances) {\n            // Careful: paramSet's key is undefined if no optimizations were made\n            if (!paramSet) break;\n            params.push(Array.from(paramSet.values()));\n            // Update names: Only once and *only* if there are parameters available; if not, keep\n            // the original empty array\n            if (!paramNames.length) {\n                paramNames = Array.from(paramSet.keys());\n            }\n        }\n        paramNames.forEach((item, index) => {\n            const row = [];\n            row.push(item);\n            for (const instanceParam of params) {\n                row.push(instanceParam[index]);\n            }\n            results.push(row);\n        });\n\n        // Add performance indicators (every indicator becomes a row)\n        const firstInstance = instances.size ? Array.from(instances.values())[0] : undefined;\n        // Only add performance results if we have instances\n        if (firstInstance) {\n            // Array with name of all performance indicators\n            const performanceIndicatorNames = Array.from(firstInstance.performanceResults.keys());\n            // Create a new row for every performance result\n            for (const performanceIndicatorName of performanceIndicatorNames) {\n                const row = [performanceIndicatorName];\n                // Add a col with the performance result of every instance\n                for (const [, instance] of instances) {\n                    row.push(instance.performanceResults.get(performanceIndicatorName));\n                }\n                results.push(row);\n            }\n        }\n\n        await exportToCsv(path.join(directory, 'performances.csv'), results);\n    }\n\n\n\n    /**\n     * Creates a new directory in which we store our data\n     * @returns {String} Folder's name (counts up)\n     */\n    createBaseFolder(directory) {\n        // Store everything in a subfolder that counts upwards; don't use current date as it's\n        // difficult to test.\n        const folderContent = fs.readdirSync(directory);\n        let folderName = 1;\n        // Walk through files/folders; if name is a valid int, set folderName to next higher int\n        folderContent.forEach((content) => {\n            const parsed = parseInt(content, 10);\n            if (!Number.isNaN(parsed)) folderName = parsed + 1;\n        });\n        return folderName;\n    }\n\n\n    /**\n     * Exports instances (all test runs)\n     * @private\n     */\n    async exportInstances() {\n\n        let index = 0;\n        for (const [params, instance] of this.instances) {\n            await this.exportInstance(++index, instance, params);\n        }\n\n    }\n\n\n    async exportAllAccounts(basePath) {\n\n        // Convert accounts data to an array with\n        // [\n        //     new Map([[runNumber: value], [runNumber: value]]),\n        //     new Map([[runNumber: value], [runNumber: value]]),\n        // ]\n        const allAccountsData = [];\n        for (const [runNumber, currentAccount] of this.exportedAccounts) {\n            // Go throught data for every account, add to allAccountsData\n            currentAccount.data.forEach((item, index) => {\n                // Add new row (with date)\n                if (!allAccountsData[index]) {\n                    allAccountsData[index] = new Map([['date', item.get('date')]]);\n                }\n                allAccountsData[index].set(runNumber, item.get('total'));\n            });\n        }\n\n        // Convert to DataSeries\n        const allAccounts = new ViewableDataSeries();\n        for (const date of allAccountsData) {\n            await allAccounts.add(date);\n        }\n\n        const exporter = new DataSeriesExporter();\n        await exporter.export(allAccounts, path.join(basePath, 'accounts'));\n        const chartExporter = new HighChartsExporter();\n        await chartExporter.export(allAccounts, basePath, 'accounts');\n\n\n    }\n\n\n\n    /**\n     * Exports a signle instance (one test run with a given set of params)\n     * @param {number} number               Index of current instance, needed for naming\n     * @param  {BacktestInstance} instance\n     * @private\n     */\n    async exportInstance(number, instance) {\n\n        const instancePath = path.join(this.directory, `run-${number}`);\n        await this.createDirectoryIfNotExists(instancePath);\n\n        const accountData = await this.exportAccount(instance.accounts.data, instancePath);\n        // Update exportedAccounts with current account data; needed to put together a view of all\n        // accounts\n        this.exportedAccounts.set(number, accountData);\n\n        await this.exportInstancePositions(instance.positions, instancePath);\n\n        // Export instruments; instance.instruments is an instance of BacktestInstruments; to\n        // access the instruments, we have to call its instruments property.\n        for (const [, instrument] of instance.instruments.instruments) {\n            await this.exportInstrument(instrument, instancePath, instance.positions);\n        }\n\n    }\n\n\n    /**\n     * Export positions for a backtest instance\n     * @param  {DataSeries} positions          Positions of an instance\n     * @param  {String} instancePath           Path to store data in\n     */\n    async exportInstancePositions(positions, instancePath) {\n\n        // Export positions: They contain objects; just take the size of every instrument instead\n        // of the whole object (that would be stringified to [object Object]).\n        const cleanPositions = new DataSeries();\n        for (const row of positions.data) {\n            // Only export positions on close\n            if (row.get('type') === 'open') continue;\n            const rowMap = new Map();\n            // Map through all columns (and not only the columns of a ctertain row) to set size to\n            // 0 (instead of undefined/empty) if no position existed\n            for (const [columnKey] of positions.columns) {\n                // key is either 'type', 'date' or an instrument; if it's instrument, value is an\n                // object with all positions and the final size. Only use this size.\n                if (columnKey instanceof Instrument) {\n                    const size = row.has(columnKey) ? row.get(columnKey).size : 0;\n                    rowMap.set(columnKey.name, size);\n                }\n                else if (columnKey === 'date') {\n                    rowMap.set(columnKey, row.get(columnKey));\n                }\n                // Ignore column 'type'\n            }\n            await cleanPositions.add(rowMap);\n        }\n\n        const exporter = new DataSeriesExporter();\n        await exporter.export(cleanPositions, path.join(instancePath, 'positions'));\n\n    }\n\n\n\n\n\n    /**\n     * Exports account consisting of invested, cash, total\n     * @param  {Array} accountData          Data property of DataSeries\n     * @param  {String} instancePath\n     * @returns {TransformableDataSeries}   Account data with all acount types added up\n     */\n    async exportAccount(accountData, instancePath) {\n\n        // Transformer that adds up invested and cash, adds column 'total'\n        class AccountTotalTransformer {\n            next(...data) {\n                return data.reduce((prev, item) => prev + item, 0);\n            }\n        }\n\n        const accountsWithTotal = new TransformableDataSeries();\n        accountsWithTotal.addTransformer(\n            ['invested', 'cash'],\n            new AccountTotalTransformer(),\n            'total',\n        );\n        for (const col of accountData) {\n            await accountsWithTotal.add(col);\n        }\n        const exporter = new DataSeriesExporter();\n        await exporter.export(accountsWithTotal, path.join(instancePath, 'accounts'));\n\n        return accountsWithTotal;\n    }\n\n\n    /**\n     * Exports a single instrument's data (that belongs to a certain instance).\n     * @param  {Instrument} instrument\n     * @param  {string} basePath         Path to export file to; file name is instrument's name.\n     * @param {DataSeries} positions     Positions (will be added to instrument in a separate\n     *                                   chart)\n     * @private\n     */\n    async exportInstrument(instrument, basePath, positions) {\n\n        const instrumentPath = path.join(basePath, this.instrumentsSubDirectory);\n\n        // Create new ViewableDataSeries for instrument; clone everything and add positions\n        // console.log('instrumentis', instrument);\n        const instrumentClone = new Instrument(instrument.name);\n        instrumentClone.viewConfig = instrument.viewConfig;\n\n        // Adds the position for a certain date to the instrument; using a transformer prevents us\n        // from editing\n        class PositionTransformer {\n            next(date) {\n                // Get correct row of positions to match current date\n                const position = positions.data.find(positionRow => (\n                    positionRow.get('type') === 'close' &&\n                    positionRow.get('date').getTime() === date.getTime()\n                ));\n                const instrumentPosition = position && position.get(instrument);\n                return instrumentPosition ? instrumentPosition.size : 0;\n            }\n            getChartConfig() {\n                return {\n                    chart: {\n                        height: 0.3,\n                        title: {\n                            text: 'Positions',\n                        },\n                    },\n                    series: {\n                        name: 'Positions',\n                        type: 'area',\n                    },\n                };\n            }\n        }\n        instrumentClone.addTransformer(['date'], new PositionTransformer(), 'Position Size');\n\n        // Move data from instrument to instrumentClone\n        for (const row of instrument.data) {\n            await instrumentClone.add(new Map(row));\n        }\n\n        // console.debug('instrument is %o', instrument.viewConfig);\n        // console.debug('instrumentClone is %o', instrumentClone.viewConfig);\n\n        await this.createDirectoryIfNotExists(instrumentPath);\n\n        // CSV export\n        const destination = path.join(instrumentPath, instrumentClone.name);\n        const exporter = new DataSeriesExporter();\n        debug('Export instrument %s to %s', instrumentClone.name, destination);\n        await exporter.export(instrumentClone, destination);\n\n        // Highstock export\n        const chartExporter = new HighChartsExporter();\n        // console.log('instrumentClone', instrument);\n        await chartExporter.export(instrumentClone, instrumentPath);\n    }\n\n\n\n\n    /**\n     * Creates a directory if it does not exist\n     * @param  {string} path        Path to directory that shall be created\n     * @private\n     */\n    createDirectoryIfNotExists(directoryPath) {\n        return new Promise((resolve, reject) => {\n            fs.access(directoryPath, fs.constants.F_OK, (err) => {\n                // No error thrown, directory exists\n                if (!err) return resolve();\n                debug('Create directory %s', directoryPath);\n                fs.mkdir(directoryPath, mkdirErr => (mkdirErr ? reject(mkdirErr) : resolve()));\n            });\n        });\n    }\n\n}\n\n\n"],"file":"BacktestExporter.mjs"}