{"version":3,"sources":["../../src/algorithm/Algorithm.mjs"],"names":["Instrument","logger","debug","Algorithm","setBacktest","backtest","getCurrentPositions","positions","data","length","Map","instrument","position","head","size","set","getInstruments","instruments","getAccounts","accounts","handleClose","orders","constructor","name","handleNewInstrument"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,0BAAvB;AACA,OAAOC,MAAP,MAAmB,kBAAnB;AAEA,MAAM;AAAEC,EAAAA;AAAF,IAAYD,MAAM,CAAC,uBAAD,CAAxB;AAEA,eAAe,MAAME,SAAN,CAAgB;AAE3B;;;;AAIAC,EAAAA,WAAW,CAACC,QAAD,EAAW;AAClB,SAAKA,QAAL,GAAgBA,QAAhB;AACH;AAED;;;;;;;;;;AAQAC,EAAAA,mBAAmB,GAAG;AAClB,QAAI,CAAC,KAAKD,QAAL,CAAcE,SAAd,CAAwBC,IAAxB,CAA6BC,MAAlC,EAA0C,OAAO,IAAIC,GAAJ,EAAP;AAC1C,UAAMH,SAAS,GAAG,IAAIG,GAAJ,EAAlB;;AACA,SAAK,MAAM,CAACC,UAAD,EAAaC,QAAb,CAAX,IAAqC,KAAKP,QAAL,CAAcE,SAAd,CAAwBM,IAAxB,EAArC,EAAqE;AACjE,UAAIF,UAAU,YAAYX,UAAtB,IAAoCY,QAAQ,CAACE,IAAT,KAAkB,CAA1D,EAA6D;AACzDP,QAAAA,SAAS,CAACQ,GAAV,CAAcJ,UAAd,EAA0BC,QAA1B;AACH;AACJ;;AACD,WAAOL,SAAP;AACH;AAED;;;;;;AAIAS,EAAAA,cAAc,GAAG;AACb,WAAO,KAAKX,QAAL,CAAcY,WAAd,CAA0BA,WAAjC;AACH;AAED;;;;;;AAIAC,EAAAA,WAAW,GAAG;AACV,WAAO,KAAKb,QAAL,CAAcc,QAArB;AACH;;AAEDC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAChBnB,IAAAA,KAAK,CAAC,uCAAD,EAA0C,KAAKoB,WAAL,CAAiBC,IAA3D,CAAL,CADgB,CAEhB;;AACA,WAAOF,MAAP;AACH;;AAEDG,EAAAA,mBAAmB,GAAG;AAClBtB,IAAAA,KAAK,CAAC,+CAAD,EAAkD,KAAKoB,WAAL,CAAiBC,IAAnE,CAAL;AACH;AAED;;;;;;AAKA;;;;;;;;;;;;;;;;;;AA5D2B","sourcesContent":["import Instrument from '../instrument/Instrument';\nimport logger from '../logger/logger';\n\nconst { debug } = logger('WalkForward:Algorithm');\n\nexport default class Algorithm {\n\n    /**\n     * Called from BacktestInstance and propagated through runAlgorithms\n     * @param {BacktestInstance} backtest    BacktestInstance that this algorithm belongs to\n     */\n    setBacktest(backtest) {\n        this.backtest = backtest;\n    }\n\n    /**\n     * Returns the current positions we're holding. Is a wrapper for this.backtest.positions.head()\n     * which filters all columns that do not contain instruments.\n     * @return {Map}      All positions we're currently holding. Key is the instrument, value an\n     *                    object with properties size (amount of instruments we're holding), value\n     *                    (value of the position we're holding for the instrument) and positions\n     *                    (all sub-positions for the instrument).\n     */\n    getCurrentPositions() {\n        if (!this.backtest.positions.data.length) return new Map();\n        const positions = new Map();\n        for (const [instrument, position] of this.backtest.positions.head()) {\n            if (instrument instanceof Instrument && position.size !== 0) {\n                positions.set(instrument, position);\n            }\n        }\n        return positions;\n    }\n\n    /**\n     * Returns all instruments available. Is a wrapper for this.backtest.instruments.instruments.\n     * @return {Array}         All instruments that are currently available\n     */\n    getInstruments() {\n        return this.backtest.instruments.instruments;\n    }\n\n    /**\n     * Returns the account; is a wrapper for this.backtest.accounts\n     * @return {DataSeries}     Accounts, a DataSeries with columns 'cash' and 'invested'.\n     */\n    getAccounts() {\n        return this.backtest.accounts;\n    }\n\n    handleClose(orders) {\n        debug('onClose method not implemented for %s', this.constructor.name);\n        // Just return the original order if class was not derived\n        return orders;\n    }\n\n    handleNewInstrument() {\n        debug('onNewInstrument method not implemented for %s', this.constructor.name);\n    }\n\n    /**\n     * Listens to newInstrument on backtest's instruments and calls corresponding\n     * handlers if available. TODO: Move newInstruments\n     * @private\n     */\n    /* setupInstrumentListeners() {\n        this.backtest.instruments.on('newInstrument', (instrument) => {\n            if (typeof this.onNewInstrument === 'function') {\n                this.onNewInstrument(instrument);\n            }\n        });\n        this.backtest.instruments.on('close', async (data) => {\n            if (typeof this.onClose === 'function') {\n                const orders = await this.onClose(this.backtest.orders, data.instrument);\n                debug('Orders are %o, pass them to backtest', orders);\n                // TODO: THIS IS FUCKING WRONG! Only main algorithm (base function) should\n                // return/set orders!\n                this.backtest.setOrders(orders);\n            }\n        });\n    } */\n\n}\n"],"file":"Algorithm.mjs"}