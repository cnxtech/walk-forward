{"version":3,"sources":["../../src/helpers/executeAlgorithmsSerially.mjs"],"names":["executeAlgorithmsSerially","algorithms","methodName","args","suppressAlgorithmErrors","useReturnValueAsFirstArgumentForSubsequentMethodCalls","Array","isArray","Error","JSON","stringify","updatedArguments","slice","result","algorithm","constructor","name"],"mappings":"AAAA;;;;;;;;;;;;;;;;;AAiBA,eAAe,eAAeA,yBAAf,CACXC,UADW,EAEXC,UAFW,EAGXC,IAHW,EAIXC,uBAAuB,GAAG,KAJf,EAKXC,qDAAqD,GAAG,KAL7C,EAMb;AAEE;AACA,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcN,UAAd,CAAL,EAAgC;AAC5B,UAAM,IAAIO,KAAJ,CAAW,yEAAwEC,IAAI,CAACC,SAAL,CAAeP,IAAf,CAAqB,EAAxG,CAAN;AACH;;AACD,MAAI,OAAOD,UAAP,KAAsB,QAA1B,EAAoC;AAChC,UAAM,IAAIM,KAAJ,CAAW,0EAAyEC,IAAI,CAACC,SAAL,CAAeP,IAAf,CAAqB,EAAzG,CAAN;AACH;;AACD,MAAI,CAACG,KAAK,CAACC,OAAN,CAAcJ,IAAd,CAAL,EAA0B;AACtB,UAAM,IAAIK,KAAJ,CAAW,wEAAuEC,IAAI,CAACC,SAAL,CAAeP,IAAf,CAAqB,EAAvG,CAAN;AACH,GAXH,CAaE;AACA;AACA;;;AACA,MAAIQ,gBAAgB,GAAGR,IAAI,CAACS,KAAL,CAAW,CAAX,CAAvB,CAhBF,CAiBE;;AACA,MAAIC,MAAJ;;AAEA,OAAK,MAAMC,SAAX,IAAwBb,UAAxB,EAAoC;AAEhC;AACA,QAAI,OAAOa,SAAP,KAAqB,QAAzB,EAAmC;AAC/B,UAAIV,uBAAJ,EAA6B;AAC7B,YAAM,IAAII,KAAJ,CAAW,uCAAsCC,IAAI,CAACC,SAAL,CAAeI,SAAf,CAA0B,oBAA3E,CAAN;AACH;;AACD,QAAI,OAAOA,SAAS,CAACZ,UAAD,CAAhB,KAAiC,UAArC,EAAiD;AAC7C,UAAIE,uBAAJ,EAA6B;AAC7B,YAAM,IAAII,KAAJ,CAAW,wCAAuCM,SAAS,CAACC,WAAV,CAAsBC,IAAK,2BAA0Bd,UAAW,GAAlH,CAAN;AACH;;AAEDW,IAAAA,MAAM,GAAG,MAAMC,SAAS,CAACZ,UAAD,CAAT,CAAsB,GAAGS,gBAAzB,CAAf,CAZgC,CAchC;AACA;;AACA,QAAIN,qDAAJ,EAA2D;AACvDM,MAAAA,gBAAgB,GAAG,CAACE,MAAD,EAAS,GAAGF,gBAAgB,CAACC,KAAjB,CAAuB,CAAvB,CAAZ,CAAnB;AACH;AAEJ,GAxCH,CA0CE;;;AACA,SAAOC,MAAP;AAEH","sourcesContent":["/**\n *  Executes the algorithms passed in one after another:\n *  - Calls methodName on first algorithm with arguments\n *  - Then calls methodName on second algorithm with arguments *but* replaces the first argument\n *    with the return value of the previous function\n *  - etc.\n *  @param {object[]} algorithms - Algorithms to call methodName on\n *  @param {string} methodName - Method to call on every algorithm\n *  @param {array} arguments - Arguments to pass to the the first algorithm\n *  @param {bool} suppressAlgorithmErrors - Dont throw an error if method on an algorithm is missing\n *                                        or not a function, just execute the next method in\n *                                        algorithm stack\n *  @param {bool} useReturnValueAsFirstArgumentForSubsequentMethodCalls - If set to true, uses\n *                                                  return value of previous method call as first\n *                                                  argument for next call\n *  @returns {*} - Result of the call of methodName on the ultimate algorithm\n */\nexport default async function executeAlgorithmsSerially(\n    algorithms,\n    methodName,\n    args,\n    suppressAlgorithmErrors = false,\n    useReturnValueAsFirstArgumentForSubsequentMethodCalls = false,\n) {\n\n    // Check arguments\n    if (!Array.isArray(algorithms)) {\n        throw new Error(`executeAlgorithmsSerially: Algorithms passed in must be an array, are ${JSON.stringify(args)}`);\n    }\n    if (typeof methodName !== 'string') {\n        throw new Error(`executeAlgorithmsSerially: Method name passed in must be an string, is ${JSON.stringify(args)}`);\n    }\n    if (!Array.isArray(args)) {\n        throw new Error(`executeAlgorithmsSerially: Arguments passed in must be an array, are ${JSON.stringify(args)}`);\n    }\n\n    // Arguments may change with every function call as we replace the first argument with the\n    // return value of the previously called methodName (when useReturnValueAsNewFirstArgument is\n    // true)\n    let updatedArguments = args.slice(0);\n    // Store the return value of every function call, return it at the end.\n    let result;\n\n    for (const algorithm of algorithms) {\n\n        // Check algorithms\n        if (typeof algorithm !== 'object') {\n            if (suppressAlgorithmErrors) continue;\n            throw new Error(`executeAlgorithmsSerially: Algorthm ${JSON.stringify(algorithm)} is not an object.`);\n        }\n        if (typeof algorithm[methodName] !== 'function') {\n            if (suppressAlgorithmErrors) continue;\n            throw new Error(`executeAlgorithmsSerially: Algorithm ${algorithm.constructor.name} does not have a method ${methodName}.`);\n        }\n\n        result = await algorithm[methodName](...updatedArguments);\n\n        // Update arguments for next iteration; return value of the previous methodCall becomes\n        // the first argument, others are preserved. Make sure to not modify any existing data.\n        if (useReturnValueAsFirstArgumentForSubsequentMethodCalls) {\n            updatedArguments = [result, ...updatedArguments.slice(1)];\n        }\n\n    }\n\n    // At the end, return the return value of the ultimate call to methodName.\n    return result;\n\n}\n"],"file":"executeAlgorithmsSerially.mjs"}