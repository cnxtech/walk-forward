{"version":3,"sources":["../../../src/sources/csv/InstrumentCSVSource.mjs"],"names":["GenericCSVSource","logger","debug","InstrumentCSVSource","constructor","instrumentNameFunction","args","Error","read","pathSpecs","join","prototype","apply","then","result","formatted","map","fileContent","formatFile","flattened","reduce","prev","item","concat","instrument","file","content","rowContent","formatRow","date","JSON","stringify","Map","set","Object","keys","forEach","key","Date","Number"],"mappings":"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","sourcesContent":["import GenericCSVSource from './GenericCSVSource';\nimport logger from '../../logger/logger';\nconst { debug } = logger('WalkForward:InstrumentCSVSource');\n\n\n/**\n* Wrapper around CSVSource that formats CSV's data for use with backtests:\n* - file name becomes instrument name\n* - date becomes a date\n* - numbers become reeeeeal numbers …\n*/\nexport default class InstrumentCSVSource extends GenericCSVSource {\n\n    /**\n     * @param  {function}    instrumentNameFunction     Function that takes the file name as an\n     *                                                  input and returns the instrument's name as\n     *                                                  a string\n     */\n    constructor(instrumentNameFunction, ...args) {\n        super(...args);\n        if (typeof instrumentNameFunction !== 'function') {\n            throw new Error(`InstrumentCSVSource: Pass a function that extracts the instrument's name from the file name as first argument of constructor, is ${instrumentNameFunction}.`);\n        }\n        this.instrumentNameFunction = instrumentNameFunction;\n    }\n\n    /**\n    * Read file (CSVSource), then re-format data retrieved.\n    * @returns {Promise}        Promise that resolves to flattened data: An array with an item per\n    *                           CSV row as a Map.\n    */\n    async read(...args) {\n        debug('Read files %s', this.pathSpecs.join(', '));\n        // https://github.com/babel/babel/issues/3930 (no super() on async methods)\n        return GenericCSVSource.prototype.read.apply(this, args).then((result) => {\n            if (result === false) return false;\n            const formatted = result.map(fileContent => this.formatFile(fileContent));\n            // Flatten array – content of all files goes into one single array (as needed by\n            // DataGenerator)\n            const flattened = formatted.reduce((prev, item) => prev.concat(item), []);\n            debug('Formatted and flattened content returned by read is %o', flattened);\n            return flattened;\n        });\n    }\n\n    /**\n    * Re-formats a file\n    * @returns {Map[]}      One array item per CSV line, formatted according to this.formatRow()\n    */\n    formatFile(fileContent) {\n        const instrument = this.instrumentNameFunction(fileContent.file);\n        debug('Get instrument name for file %s, is %s', fileContent.file, instrument);\n        return fileContent.content.map(rowContent => (\n            this.formatRow(rowContent, instrument)\n        ));\n    }\n\n    /**\n    * Formats a single CSV row to the format matching Backtest.\n    * @returns {Map}        Map that contains at least the keys 'date' {Date} and\n    *                       'instrument' {String} as well as all other CSV columns as {Number}\n    */\n    formatRow(rowContent, instrument) {\n        debug('Format row %o for instrument %s', rowContent, instrument);\n        if (!instrument) {\n            throw new Error(`InstrumentCSVSource: Instrument not provided (maybe you passed an instrumentNameFunction that does not work as expected), is ${instrument}.`);\n        }\n        if (!rowContent.date) {\n            throw new Error(`InstrumentCSVSource: Data does not contain a date field, is ${JSON.stringify(rowContent)}.`);\n        }\n        const formatted = new Map();\n        formatted.set('instrument', instrument);\n        // Go through all properties of rowContent; convert all to numbers except date which\n        // becomes a new Date().\n        Object.keys(rowContent).forEach((key) => {\n            if (key === 'date') formatted.set(key, new Date(rowContent[key]));\n            else formatted.set(key, Number(rowContent[key]));\n        });\n        return formatted;\n    }\n\n}\n"],"file":"InstrumentCSVSource.mjs"}