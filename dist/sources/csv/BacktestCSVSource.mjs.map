{"version":3,"sources":["../../../src/sources/csv/BacktestCSVSource.mjs"],"names":["dataSortFunction","groupArrayByValue","BacktestCSVSource","constructor","csvSource","Error","read","generate","setupData","key","content","csvDataGroupedByDate","csvReadingPromise","csvData","sortedCSVData","slice","sort","item","get","getTime"],"mappings":";;AAAA,OAAOA,gBAAP,MAA6B,oCAA7B;AACA,OAAOC,iBAAP,MAA8B,qCAA9B;AAGA;;;;;;AAKA,eAAe,MAAMC,iBAAN,CAAwB;AAEnC;;;AAKAC,EAAAA,WAAW,CAACC,SAAD,EAAY;AAAA,+CAFH,KAEG;;AACnB,QAAI,CAACA,SAAL,EAAgB;AACZ,YAAM,IAAIC,KAAJ,CAAW,8DAA6DD,SAAU,GAAlF,CAAN;AACH;;AACD,QAAI,CAACA,SAAS,CAACE,IAAX,IAAmB,OAAOF,SAAS,CAACE,IAAjB,KAA0B,UAAjD,EAA6D;AACzD,YAAM,IAAID,KAAJ,CAAW,iFAAgFD,SAAS,CAACE,IAAK,GAA1G,CAAN;AACH;;AACD,SAAKF,SAAL,GAAiBA,SAAjB;AACH;AAED;;;;;AAGA,SAAOG,QAAP,GAAkB;AACd,UAAM,KAAKC,SAAL,EAAN,CADc,CAEd;;AACA,SAAK,MAAM,CAACC,GAAD,EAAMC,OAAN,CAAX,IAA6B,KAAKC,oBAAlC,EAAwD;AACpD,YAAMD,OAAN;AACH;AACJ;AAED;;;;;;;AAKA,QAAMF,SAAN,GAAkB;AACd;AACA,QAAI,CAAC,KAAKI,iBAAV,EAA6B;AACzB,WAAKA,iBAAL,GAAyB,KAAKR,SAAL,CAAeE,IAAf,EAAzB;AACA,YAAMO,OAAO,GAAG,MAAM,KAAKD,iBAA3B,CAFyB,CAGzB;AACA;;AACA,YAAME,aAAa,GAAGD,OAAO,CAACE,KAAR,CAAc,CAAd,EAAiBC,IAAjB,CAAsBhB,gBAAtB,CAAtB;AACA,WAAKW,oBAAL,GAA4BV,iBAAiB,CACzCa,aADyC,EAEzC;AACA;AACAG,MAAAA,IAAI,IAAIA,IAAI,CAACC,GAAL,CAAS,MAAT,EAAiBC,OAAjB,EAJiC,CAA7C;AAMH,KAZD,CAaA;AAbA,SAcK;AACD,cAAM,KAAKP,iBAAX;AACH;AACJ;;AApDkC","sourcesContent":["import dataSortFunction from '../../helpers/dataSortFunction.mjs';\nimport groupArrayByValue from '../../helpers/groupArrayByValue.mjs';\n\n\n/**\n* CSV source that has been reformatted to return the results expected by BacktestInstruments,\n* i.e. is an async generator. Makes sure that data are only read once (to minimize I/O operations)\n* by using a promise for reading data.\n */\nexport default class BacktestCSVSource {\n\n    /**\n     * Turns to true as soon as we have started reading CSV data\n     */\n    csvReadingPromise = false;\n\n    constructor(csvSource) {\n        if (!csvSource) {\n            throw new Error(`BacktestCSVSource: Pass a valid CSV source as argument, is ${csvSource}.`);\n        }\n        if (!csvSource.read || typeof csvSource.read !== 'function') {\n            throw new Error(`BacktestCSVSource: Make sure the CSV source you pass in has a read method, is ${csvSource.read}.`);\n        }\n        this.csvSource = csvSource;\n    }\n\n    /**\n     * Main function: Reads CSV, sorts data and yields it interval by interval (e.g. daily)\n     */\n    async* generate() {\n        await this.setupData();\n        // eslint-disable-next-line no-unused-vars\n        for (const [key, content] of this.csvDataGroupedByDate) {\n            yield content;\n        }\n    }\n\n    /**\n     * Reads data from source passed in, sorts and groups it and stores it in\n     * this.csvDataGroupedByDate\n     * @private\n     */\n    async setupData() {\n        // First call: Fetch all data, sort and store it.\n        if (!this.csvReadingPromise) {\n            this.csvReadingPromise = this.csvSource.read();\n            const csvData = await this.csvReadingPromise;\n            // Sort by date first so that all entries in the map grouped by date are\n            // chronologically sorted\n            const sortedCSVData = csvData.slice(0).sort(dataSortFunction);\n            this.csvDataGroupedByDate = groupArrayByValue(\n                sortedCSVData,\n                // Make sure we use a Number (and not a native date) to group items by as a Date\n                // instance will never equal another Date instance\n                item => item.get('date').getTime(),\n            );\n        }\n        // Subsequent calls: Wait to make sure data is ready\n        else {\n            await this.csvReadingPromise;\n        }\n    }\n\n}\n"],"file":"BacktestCSVSource.mjs"}