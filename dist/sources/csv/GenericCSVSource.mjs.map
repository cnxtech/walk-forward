{"version":3,"sources":["../../../src/sources/csv/GenericCSVSource.mjs"],"names":["csv","logger","getPathsFromSpecs","debug","GenericCSVSource","constructor","pathSpecs","headers","Array","isArray","Error","JSON","stringify","read","allRead","Promise","resolve","readPromise","reject","readInternally","then","result","undefined","allFiles","promises","map","file","fileContent","readFile","content","all","path","fromPath","csvOptions","on","data","concat","err"],"mappings":"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","sourcesContent":["import csv from 'fast-csv';\nimport logger from '../../logger/logger';\nimport { getPathsFromSpecs } from './specToPath';\n\nconst { debug } = logger('WalkForward:GenericCSVSource');\n\n/**\n* Reads multiple CSV files and returns the result. Accepts globs as path specifiers.\n*/\nexport default class GenericCSVSource {\n\n    pathSpecs = [];\n    csvOptions = {\n        headers: true,\n    }\n\n    /**\n    * @param {array|string} pathSpecs       Paths to CSVs to read; you may use glob patterns\n    */\n    constructor(pathSpecs) {\n\n        if (typeof pathSpecs === 'string') {\n            this.pathSpecs = [pathSpecs];\n        }\n        else if (Array.isArray(pathSpecs)) {\n            this.pathSpecs = pathSpecs;\n        }\n        else {\n            throw new Error(`GenericCSVSource: First argument must be an array of paths or a string, is '${JSON.stringify(pathSpecs)}'.`);\n        }\n\n    }\n\n\n    /**\n    * Reads all files that match a path specified in this.pathSpecs, converts it to a\n    * DataSeries and resolves promise with all dataSeries\n    * Don't use an async function as the promise it returns won't be the same as the one\n    * stored in this.readPromise (?), which is a requirement in our tests (maybe it's a babel\n    * issue)\n    * @returns {Promise}        Promise that resolves to an array where every file read\n    *                           is an item and contains two properties: file (string) and content\n    *                           (array of objects)\n    */\n    read() {\n        // If we're already reading, don't start a new read, just return the existing promise.\n        // This is especially important as multiple read calls might be made if we optimize\n        // a backtest with different variables (one call per run might be made).\n        if (this.allRead) return Promise.resolve(false);\n        if (this.readPromise) return this.readPromise;\n        this.readPromise = new Promise((resolve, reject) => {\n            this.readInternally().then((result) => {\n                debug('Read internally, result is', result);\n                this.allRead = true;\n                this.readPromise = undefined;\n                resolve(result);\n            }, reject);\n        });\n        debug('Reading files, return promise');\n        return this.readPromise;\n    }\n\n\n    /**\n    * Does actually read the files; is masked by read which makes sure that we don't read\n    * multiple times by returning the read promise if it exists\n    * @private\n    */\n    async readInternally() {\n        const allFiles = await getPathsFromSpecs(this.pathSpecs);\n        debug('Read files %o', allFiles);\n        const promises = allFiles.map(async(file) => {\n            const fileContent = await this.readFile(file);\n            return {\n                file,\n                content: fileContent,\n            };\n        });\n        return Promise.all(promises);\n\n    }\n\n\n    /**\n    * Reads a single file and converts it into a DataSeries\n    * @param {string} path      Path to the file that should be read\n    * @returns promise\n    */\n    readFile(path) {\n\n        debug('Read file %s', path);\n\n        let content = [];\n        return new Promise((resolve, reject) => {\n            csv\n                .fromPath(path, this.csvOptions)\n                .on('data', (data) => {\n                    content = content.concat(data);\n                })\n                .on('end', () => {\n                    debug('File %s completely read', path);\n                    resolve(content);\n                })\n                .on('data-invalid', (err) => {\n                    debug('Reading file %s failed: %o', path, err);\n                    reject(new Error(err));\n                })\n                .on('error', (err) => {\n                    debug('Reading file %s failed: %o', path, err);\n                    reject(new Error(err));\n                });\n        });\n\n    }\n\n}\n\n"],"file":"GenericCSVSource.mjs"}