{"version":3,"sources":["../../src/indicators/createIndicator.mjs"],"names":["logger","debug","createIndicator","indicatorConfig","constructor","args","Array","from","length","inputs","map","options","Error","name","join","option_names","next","values","input_names","forEach","value","index","history","push","Promise","resolve","reject","indicator","err","results","identifier","latestResult","result","undefined","resultMap","reduce","prev","item","set","output_names","Map"],"mappings":";;AAAA,OAAOA,MAAP,MAAmB,kBAAnB;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAYD,MAAM,CAAC,6BAAD,CAAxB;AAEA;;;;AAGA,eAAe,SAASE,eAAT,CAAyBC,eAAzB,EAA0C;AAAA;;AAErD,0BAAO,MAAM;AAET;;;;AAMA;AACA;AACA;AAGAC,IAAAA,WAAW,CAAC,GAAGC,IAAJ,EAAU;AAAA,uCAFXC,KAAK,CAACC,IAAN,CAAW;AAAEC,QAAAA,MAAM,EAAEL,eAAe,CAACM;AAA1B,OAAX,EAA+CC,GAA/C,CAAmD,MAAM,EAAzD,CAEW;;AACjB,UAAIL,IAAI,CAACG,MAAL,KAAgBL,eAAe,CAACQ,OAApC,EAA6C;AACzC,cAAM,IAAIC,KAAJ,CAAW,cAAcT,eAAe,CAACU,IAAK;0CACzBV,eAAe,CAACQ,OAAS;sBAC7CN,IAAI,CAACS,IAAL,CAAU,IAAV,CAAiB,cAAcX,eAAe,CAACY,YAAhB,CAA6BD,IAA7B,CAAkC,IAAlC,CAAyC,GAFzE,CAAN;AAGH,OALgB,CAMjB;;;AACA,WAAKH,OAAL,GAAeN,IAAf;AACH;AAED;;;;;;;;AAMAW,IAAAA,IAAI,CAAC,GAAGC,MAAJ,EAAY;AAEZ;AACA,UAAIA,MAAM,CAACT,MAAP,KAAkBL,eAAe,CAACM,MAAtC,EAA8C;AAC1C,cAAM,IAAIG,KAAJ,CAAW,cAAcT,eAAe,CAACU,IAAM;8BACtCI,MAAM,CAACH,IAAP,CAAY,IAAZ,CAAmB;sBAC3BX,eAAe,CAACe,WAAhB,CAA4BJ,IAA5B,CAAiC,IAAjC,CAAwC,GAFzC,CAAN;AAGH,OAPW,CASZ;AACA;;;AACAG,MAAAA,MAAM,CAACE,OAAP,CAAe,CAACC,KAAD,EAAQC,KAAR,KAAkB,KAAKC,OAAL,CAAaD,KAAb,EAAoBE,IAApB,CAAyBH,KAAzB,CAAjC;AAEA,aAAO,IAAII,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpCvB,QAAAA,eAAe,CAACwB,SAAhB,CAA0B,KAAKL,OAA/B,EAAwC,KAAKX,OAA7C,EAAsD,CAACiB,GAAD,EAAMC,OAAN,KAAkB;AACpE5B,UAAAA,KAAK,CAAC,qBAAD,EAAwB,KAAKG,WAAL,CAAiB0B,UAAzC,CAAL;AACA,cAAIF,GAAJ,EAASF,MAAM,CAACE,GAAD,CAAN,CAF2D,CAGpE;AACA;;AACA,gBAAMG,YAAY,GAAGF,OAAO,CAACnB,GAAR,CAAasB,MAAD,IAAY;AACzC,mBAAOA,MAAM,CAACxB,MAAP,GAAgBwB,MAAM,CAACA,MAAM,CAACxB,MAAP,GAAgB,CAAjB,CAAtB,GAA4CyB,SAAnD;AACH,WAFoB,CAArB,CALoE,CAQpE;;AACA,cAAIF,YAAY,CAACvB,MAAb,KAAwB,CAA5B,EAA+B,OAAOiB,OAAO,CAACM,YAAY,CAAC,CAAD,CAAb,CAAd,CATqC,CAUpE;AACA;;AACA,gBAAMG,SAAS,GAAGH,YAAY,CAACI,MAAb,CAAoB,CAACC,IAAD,EAAOC,IAAP,EAAahB,KAAb,KAAuB;AACzDe,YAAAA,IAAI,CAACE,GAAL,CAASnC,eAAe,CAACoC,YAAhB,CAA6BlB,KAA7B,CAAT,EAA8CgB,IAA9C;AACA,mBAAOD,IAAP;AACH,WAHiB,EAGf,IAAII,GAAJ,EAHe,CAAlB;AAIAf,UAAAA,OAAO,CAACS,SAAD,CAAP;AACH,SAjBD;AAkBH,OAnBM,CAAP;AAqBH;;AA/DQ,GAAb,wCAMwB/B,eAAe,CAACU,IANxC;AAmEH","sourcesContent":["import logger from '../logger/logger';\nconst { debug } = logger('WalkForward:createIndicator');\n\n/**\n * A factory function that creates indicators from tulind\n */\nexport default function createIndicator(indicatorConfig) {\n\n    return class {\n\n        /**\n         * Needed for chartConfigs\n         * @private\n         */\n        static identifier = indicatorConfig.name;\n\n        // We'll store past values in this.history as options (e.g. sma length) might change and \n        // previous values might be required to calculate the result.\n        // Create one item per input needed\n        history = Array.from({ length: indicatorConfig.inputs }).map(() => []);\n\n        constructor(...args) {\n            if (args.length !== indicatorConfig.options) {\n                throw new Error(`Indicators/${ indicatorConfig.name}: Number of constructor  \n                    arguments required: ${ indicatorConfig.options }, arguments provided: \n                    ${ args.join(', ') }, expected ${ indicatorConfig.option_names.join(', ') }.`);\n            }\n            // Store options\n            this.options = args;\n        }\n\n        /**\n         * Add number(s) to indicator, then call it\n         * @param  {values} values     number\n         * @return {Promise}           Resolves to a single value if the indicator returns a single\n         *                             value, else returns to a map: new Map([[output_name, value]])\n         */\n        next(...values) {\n\n            // Test number of arguments passed\n            if (values.length !== indicatorConfig.inputs) {\n                throw new Error(`Indicators/${ indicatorConfig.name }: Arguments passed to\n                    next(): ${ values.join(', ') }, expected: \n                    ${ indicatorConfig.input_names.join(', ') }.`);\n            }\n\n            // Add value to history: History is an array A of arrays B where one array A is created\n            // per value passed.\n            values.forEach((value, index) => this.history[index].push(value));\n\n            return new Promise((resolve, reject) => {\n                indicatorConfig.indicator(this.history, this.options, (err, results) => {\n                    debug('next() called on %s', this.constructor.identifier);\n                    if (err) reject(err);\n                    // tulip returns an array of results, going back in time; just return the \n                    // most recent result or undefined for every output gotten.\n                    const latestResult = results.map((result) => {\n                        return result.length ? result[result.length - 1] : undefined;\n                    });\n                    // If indicator returns just one value, return it directly.\n                    if (latestResult.length === 1) return resolve(latestResult[0]);\n                    // Convert array to a map where the keys are the names and the values the \n                    // values, e.g. new Map([['stoch_k', 3], ['stoch_d', 2]])\n                    const resultMap = latestResult.reduce((prev, item, index) => {\n                        prev.set(indicatorConfig.output_names[index], item);\n                        return prev;\n                    }, new Map());\n                    resolve(resultMap);\n                });\n            });\n\n        }\n\n    };\n\n}"],"file":"createIndicator.mjs"}