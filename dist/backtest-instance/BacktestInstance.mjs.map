{"version":3,"sources":["../../src/backtest-instance/BacktestInstance.mjs"],"names":["logger","executeOrders","DataSeries","Positions","calculatePositionsValues","formatDate","formatInstruments","formatOrders","formatPositions","executeAlgorithmsSerially","Instrument","log","BacktestInstance","constructor","instruments","algorithmStack","backtestConfig","Map","debug","Array","from","values","config","run","on","instrument","date","length","head","get","info","updatePositionValues","orders","validateOrders","setOrders","Error","JSON","stringify","order","Object","prototype","hasOwnProperty","call","size","currentDate","prices","getCurrentPrices","updatedPositions","positions","getPositions","newInvestedValue","reduce","prev","position","value","accounts","add","set","recalculatedPositions","account","createAccount","newPositions","previousValue","newInvested","newCash","newAccountValues","calculatePerformanceIndicators","indicators","indicator","result","calculate","performanceResults","getName","type"],"mappings":";;AAAA,OAAOA,MAAP,MAAmB,kBAAnB;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,UAAP,MAAuB,2BAAvB;AACA,OAAOC,SAAP,MAAsB,wBAAtB;AACA,OAAOC,wBAAP,MAAqC,4BAArC;AACA,SACIC,UADJ,EAEIC,iBAFJ,EAGIC,YAHJ,EAIIC,eAJJ,QAKO,uBALP;AAMA,OAAOC,yBAAP,MAAsC,sCAAtC;AACA,OAAOC,UAAP,MAAuB,0BAAvB;AAEA,MAAMC,GAAG,GAAGX,MAAM,CAAC,8BAAD,CAAlB;AAEA;;;;;AAIA,eAAe,MAAMY,gBAAN,CAAuB;AAElC;;;;;AAMA;;;;;AAMA;;;;;AAOA;;;;;;AAQA;;;;;;;;;AASAC,EAAAA,WAAW,CAACC,WAAD,EAAcC,cAAd,EAA8BC,cAA9B,EAA8C;AAAA,oCAhChD,EAgCgD;;AAAA,uCA1B7C,IAAIb,SAAJ,EA0B6C;;AAAA,sCApB9C,IAAID,UAAJ,EAoB8C;;AAAA,gDAZpC,IAAIe,GAAJ,EAYoC;;AACrD;AACAN,IAAAA,GAAG,CAACO,KAAJ,CACI,gDADJ,EAEIZ,iBAAiB,CAACa,KAAK,CAACC,IAAN,CAAWN,WAAW,CAACA,WAAZ,CAAwBO,MAAnC,CAAD,CAFrB;AAIA,SAAKP,WAAL,GAAmBA,WAAnB;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKO,MAAL,GAAcN,cAAd;AACH;AAGD;;;;;AAGA,QAAMO,GAAN,GAAY;AAER;AACA,UAAMd,yBAAyB,CAC3B,KAAKM,cADsB,EAE3B,aAF2B,EAG3B,CAAC,IAAD,CAH2B,EAI3B,IAJ2B,CAA/B;AAOA,SAAKD,WAAL,CAAiBU,EAAjB,CAAoB,eAApB,EAAqC,MAAMC,UAAN,IAAqB;AACtD,YAAMhB,yBAAyB,CAC3B,KAAKM,cADsB,EAE3B,qBAF2B,EAG3B,CAACU,UAAD,CAH2B,EAI3B,IAJ2B,CAA/B;AAMH,KAPD;AASA,SAAKX,WAAL,CAAiBU,EAAjB,CAAoB,OAApB,EAA6B,MAAMV,WAAN,IAAsB;AAC/C,YAAMY,IAAI,GAAGZ,WAAW,CAACa,MAAZ,IAAsBb,WAAW,CAAC,CAAD,CAAX,CAAec,IAAf,GAAsBC,GAAtB,CAA0B,MAA1B,CAAnC;AACAlB,MAAAA,GAAG,CAACmB,IAAJ,CACI,yCADJ,EAEIxB,iBAAiB,CAACQ,WAAD,CAFrB,EAGIT,UAAU,CAACqB,IAAD,CAHd,EAF+C,CAO/C;AACA;;AACA,WAAKK,oBAAL,CAA0BjB,WAA1B;AACA,YAAMkB,MAAM,GAAG,MAAMvB,yBAAyB,CAC1C,KAAKM,cADqC,EAE1C,aAF0C,EAG1C,CAAC,IAAIE,GAAJ,EAAD,EAAYH,WAAZ,CAH0C,EAI1C,IAJ0C,EAK1C,IAL0C,CAA9C,CAV+C,CAiB/C;;AACA,WAAKmB,cAAL,CAAoBD,MAApB;AACArB,MAAAA,GAAG,CAACmB,IAAJ,CACI,oCADJ,EAEIzB,UAAU,CAACqB,IAAD,CAFd,EAGInB,YAAY,CAACyB,MAAD,CAHhB;AAKA,WAAKE,SAAL,CAAeF,MAAf;AACH,KAzBD;AA2BA,SAAKlB,WAAL,CAAiBU,EAAjB,CAAoB,MAApB,EAA6BV,WAAD,IAAiB;AACzC,YAAMY,IAAI,GAAGZ,WAAW,CAACa,MAAZ,IAAsBb,WAAW,CAAC,CAAD,CAAX,CAAec,IAAf,GAAsBC,GAAtB,CAA0B,MAA1B,CAAnC;AACAlB,MAAAA,GAAG,CAACmB,IAAJ,CACI,uCADJ,EAEIzB,UAAU,CAACqB,IAAD,CAFd,EAGIpB,iBAAiB,CAACQ,WAAD,CAHrB;AAKA,WAAKb,aAAL,CAAmBa,WAAnB;AACH,KARD;AAUA,UAAM,KAAKA,WAAL,CAAiBS,GAAjB,EAAN;AAEH;AAGD;;;;;;;;AAMAW,EAAAA,SAAS,CAACF,MAAD,EAAS;AACd,SAAKA,MAAL,GAAcA,MAAd;AACH;AAGD;;;;;;;;AAMAC,EAAAA,cAAc,CAACD,MAAD,EAAS;AAEnB;AACA,QAAI,EAAEA,MAAM,YAAYf,GAApB,CAAJ,EAA8B;AAC1B,YAAM,IAAIkB,KAAJ,CAAW,sDAAqDC,IAAI,CAACC,SAAL,CAAeL,MAAf,CAAuB,EAAvF,CAAN;AACH,KALkB,CAOnB;;;AACA,SAAK,MAAM,CAACP,UAAD,EAAaa,KAAb,CAAX,IAAkCN,MAAlC,EAA0C;AACtC,UAAI,EAAEP,UAAU,YAAYf,UAAxB,CAAJ,EAAyC;AACrC,cAAM,IAAIyB,KAAJ,CAAW,6EAA4EC,IAAI,CAACC,SAAL,CAAeZ,UAAf,CAA2B,WAAlH,CAAN;AACH;;AAED,UAAI,CAACc,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCJ,KAArC,EAA4C,MAA5C,CAAL,EAA0D;AACtD,cAAM,IAAIH,KAAJ,CAAW,2EAA0EC,IAAI,CAACC,SAAL,CAAeC,KAAf,CAAsB,WAA3G,CAAN;AACH;;AAED,UAAI,OAAOA,KAAK,CAACK,IAAb,KAAsB,QAA1B,EAAoC;AAChC,cAAM,IAAIR,KAAJ,CAAW,gFAA+EC,IAAI,CAACC,SAAL,CAAeC,KAAK,CAACK,IAArB,CAA2B,WAArH,CAAN;AACH;AACJ;AAEJ;AAGD;;;;;;;AAKAZ,EAAAA,oBAAoB,CAACjB,WAAD,EAAc;AAE9B,UAAM8B,WAAW,GAAG9B,WAAW,CAAC,CAAD,CAAX,CAAec,IAAf,GAAsBC,GAAtB,CAA0B,MAA1B,CAApB;AACA,UAAMgB,MAAM,GAAG,KAAKC,gBAAL,CAAsBhC,WAAtB,EAAmC,OAAnC,CAAf,CAH8B,CAK9B;AACA;;AACA,UAAMiC,gBAAgB,GAAG3C,wBAAwB,CAC7C,KAAK4C,SAAL,CAAeC,YAAf,CAA4B,KAAKD,SAAL,CAAepB,IAAf,EAA5B,CAD6C,EAE7CiB,MAF6C,CAAjD,CAP8B,CAY9B;;AACA,UAAMK,gBAAgB,GAAG/B,KAAK,CACzBC,IADoB,CACf2B,gBAAgB,CAAC1B,MAAjB,EADe,EAEpB8B,MAFoB,CAEb,CAACC,IAAD,EAAOC,QAAP,KAAoBD,IAAI,GAAGC,QAAQ,CAACC,KAFvB,EAE8B,CAF9B,CAAzB;AAGA,SAAKC,QAAL,CAAcC,GAAd,CAAkB,IAAIvC,GAAJ,CAAQ,CACtB,CAAC,MAAD,EAAS2B,WAAT,CADsB,EAEtB,CAAC,MAAD,EAAS,OAAT,CAFsB,EAGtB;AACA,KAAC,MAAD,EAAS,KAAKW,QAAL,CAAc3B,IAAd,GAAqBC,GAArB,CAAyB,MAAzB,CAAT,CAJsB,EAKtB,CAAC,UAAD,EAAaqB,gBAAb,CALsB,CAAR,CAAlB,EAhB8B,CAwB9B;;AACAH,IAAAA,gBAAgB,CAACU,GAAjB,CAAqB,MAArB,EAA6Bb,WAA7B;AACAG,IAAAA,gBAAgB,CAACU,GAAjB,CAAqB,MAArB,EAA6B,OAA7B;AAEA9C,IAAAA,GAAG,CAACmB,IAAJ,CACI,gDADJ,EAEIzB,UAAU,CAACuC,WAAD,CAFd,EAGIpC,eAAe,CAACuC,gBAAD,CAHnB;AAKApC,IAAAA,GAAG,CAACmB,IAAJ,CACI,4CADJ,EAEIzB,UAAU,CAACuC,WAAD,CAFd,EAGI,KAAKW,QAAL,CAAc3B,IAAd,GAAqBC,GAArB,CAAyB,MAAzB,CAHJ,EAII,KAAK0B,QAAL,CAAc3B,IAAd,GAAqBC,GAArB,CAAyB,UAAzB,CAJJ,EAKI,KAAK0B,QAAL,CAAc3B,IAAd,GAAqBC,GAArB,CAAyB,MAAzB,IAAmC,KAAK0B,QAAL,CAAc3B,IAAd,GAAqBC,GAArB,CAAyB,UAAzB,CALvC,EAjC8B,CAyC9B;AACA;;AACA,SAAKmB,SAAL,CAAeQ,GAAf,CAAmBT,gBAAnB;AACH;AAGD;;;;;;;;AAMA9C,EAAAA,aAAa,CAACa,WAAD,EAAc;AAEvB,UAAM8B,WAAW,GAAG9B,WAAW,CAAC,CAAD,CAAX,CAAec,IAAf,GAAsBC,GAAtB,CAA0B,MAA1B,CAApB;AACAlB,IAAAA,GAAG,CAACmB,IAAJ,CACI,oDADJ,EAEIzB,UAAU,CAACuC,WAAD,CAFd,EAGIrC,YAAY,CAAC,KAAKyB,MAAN,CAHhB,EAII1B,iBAAiB,CAACQ,WAAD,CAJrB;AAOA,UAAM+B,MAAM,GAAG,KAAKC,gBAAL,CAAsBhC,WAAtB,EAAmC,MAAnC,CAAf,CAVuB,CAYvB;;AACA,UAAM4C,qBAAqB,GAAGtD,wBAAwB,CAClD,KAAK4C,SAAL,CAAeC,YAAf,CAA4B,KAAKD,SAAL,CAAepB,IAAf,EAA5B,CADkD,EAElDiB,MAFkD,CAAtD;AAKA,UAAMc,OAAO,GAAG,KAAKJ,QAAL,CAAc3B,IAAd,MAAwB,KAAKgC,aAAL,EAAxC;AACA,UAAMC,YAAY,GAAG5D,aAAa,CAC9ByD,qBAD8B,EAE9B,KAAK1B,MAFyB,EAG9Ba,MAH8B,EAI9Bc,OAAO,CAAC9B,GAAR,CAAY,MAAZ,CAJ8B,CAAlC;AAMAlB,IAAAA,GAAG,CAACmB,IAAJ,CACI,mCADJ,EAEIzB,UAAU,CAACuC,WAAD,CAFd,EAGIpC,eAAe,CAAC,KAAKwC,SAAL,CAAepB,IAAf,MAAyB,IAAIX,GAAJ,EAA1B,CAHnB,EAIIT,eAAe,CAACqD,YAAD,CAJnB,EAzBuB,CAiCvB;AACA;AACA;;AACA,UAAMC,aAAa,GAAG3C,KAAK,CAACC,IAAN,CAAWsC,qBAAqB,CAACrC,MAAtB,EAAX,EACjB8B,MADiB,CACV,CAACC,IAAD,EAAOC,QAAP,KAAoBD,IAAI,GAAGC,QAAQ,CAACC,KAD1B,EACiC,CADjC,CAAtB;AAEA,UAAMS,WAAW,GAAG5C,KAAK,CAACC,IAAN,CAAWyC,YAAY,CAACxC,MAAb,EAAX,EACf8B,MADe,CACR,CAACC,IAAD,EAAOC,QAAP,KAAoBD,IAAI,GAAGC,QAAQ,CAACC,KAD5B,EACmC,CADnC,CAApB,CAtCuB,CAyCvB;AACA;;AACA,UAAMU,OAAO,GAAGL,OAAO,CAAC9B,GAAR,CAAY,MAAZ,KAAuBiC,aAAa,GAAGC,WAAvC,CAAhB;AACA,UAAME,gBAAgB,GAAG,IAAIhD,GAAJ,CAAQ,CAC7B,CAAC,MAAD,EAAS2B,WAAT,CAD6B,EAE7B,CAAC,MAAD,EAAS,MAAT,CAF6B,EAG7B,CAAC,MAAD,EAASoB,OAAT,CAH6B,EAI7B,CAAC,UAAD,EAAaD,WAAb,CAJ6B,CAAR,CAAzB;AAMApD,IAAAA,GAAG,CAACmB,IAAJ,CACI,4CADJ,EAEIzB,UAAU,CAACuC,WAAD,CAFd,EAGIoB,OAHJ,EAIID,WAJJ,EAKIC,OAAO,GAAGD,WALd;AAQA,SAAKR,QAAL,CAAcC,GAAd,CAAkBS,gBAAlB,EA1DuB,CA4DvB;AACA;;AACAJ,IAAAA,YAAY,CAACJ,GAAb,CAAiB,MAAjB,EAAyBb,WAAzB;AACAiB,IAAAA,YAAY,CAACJ,GAAb,CAAiB,MAAjB,EAAyB,MAAzB;AACA,SAAKT,SAAL,CAAeQ,GAAf,CAAmBK,YAAnB,EAhEuB,CAkEvB;;AACA,SAAK3B,SAAL,CAAe,IAAIjB,GAAJ,EAAf;AAEH;AAGD;;;;;;;;;;AAQA,QAAMiD,8BAAN,CAAqCC,UAArC,EAAiD;AAC7C,SAAK,MAAMC,SAAX,IAAwBD,UAAxB,EAAoC;AAChC,YAAME,MAAM,GAAG,MAAMD,SAAS,CAACE,SAAV,CAAoB,IAApB,CAArB;AACA,WAAKC,kBAAL,CAAwBd,GAAxB,CAA4BW,SAAS,CAACI,OAAV,EAA5B,EAAiDH,MAAjD;AACH;AACJ;AAGD;;;;;;;;;;AAQAvB,EAAAA,gBAAgB,CAAChC,WAAD,EAAc2D,IAAd,EAAoB;AAChC,WAAO3D,WAAW,CAACqC,MAAZ,CAAmB,CAACC,IAAD,EAAO3B,UAAP,KAAsB;AAC5C2B,MAAAA,IAAI,CAACK,GAAL,CAAShC,UAAT,EAAqBA,UAAU,CAACG,IAAX,GAAkBC,GAAlB,CAAsB4C,IAAtB,CAArB;AACA,aAAOrB,IAAP;AACH,KAHM,EAGJ,IAAInC,GAAJ,EAHI,CAAP;AAIH;AAGD;;;;;AAGA2C,EAAAA,aAAa,GAAG;AACZ,WAAO,IAAI3C,GAAJ,CAAQ,CACX,CAAC,MAAD,EAAU,KAAKK,MAAL,IAAe,KAAKA,MAAL,CAAYO,GAAZ,CAAgB,MAAhB,CAAhB,IAA4C,CAArD,CADW,EAEX,CAAC,UAAD,EAAa,CAAb,CAFW,CAAR,CAAP;AAIH;;AAtUiC","sourcesContent":["import logger from '../logger/logger';\nimport executeOrders from './executeOrders';\nimport DataSeries from '../data-series/DataSeries';\nimport Positions from '../positions/Positions';\nimport calculatePositionsValues from './calculatePositionsValues';\nimport {\n    formatDate,\n    formatInstruments,\n    formatOrders,\n    formatPositions,\n} from '../helpers/formatLogs';\nimport executeAlgorithmsSerially from '../helpers/executeAlgorithmsSerially';\nimport Instrument from '../instrument/Instrument';\n\nconst log = logger('WalkForward:BacktestInstance');\n\n/**\n* Instance of a backtest that runs a backtest with certain parameters.\n* Starts the backtest, executes the orders – does the actual trading.\n*/\nexport default class BacktestInstance {\n\n    /**\n     * Orders: An array of orders, updated on close, executed on afterOpen and then cleared\n     * (good for 1 day only)\n     */\n    orders = [];\n\n    /**\n     * Positions: Current positions as a DataSeries, every instrument has its column, value is\n     * the position size\n     */\n    positions = new Positions();\n\n    /**\n     * Account: Current cash and instrument values for every date, cols are cash, invested\n     * later all fees, and every instrument\n     */\n    accounts = new DataSeries();\n\n\n    /**\n     * Holds results of performanceIndicators if they are executed through\n     * calculatePerformanceIndicators\n     * @type {Map}\n     */\n    performanceResults = new Map();\n\n\n    /**\n    * @πaram {BacktestInstruments} instruments          Instruments to run backtest on.\n    * @param {BacktestInstruments} instruments          Instruments that backtest is executed for\n    * @param {objectt[]} algorithmStack                 Array of objects with handleOpen and\n    *                                                   handleNewInstrument methods that are called\n    *                                                   on corresponding events of instruments.\n    * @param {Map<string, function>} backtestConfig     Backtest configuration (to calculate\n    *                                                   commission, set default cash amount etc.)\n    */\n    constructor(instruments, algorithmStack, backtestConfig) {\n        // No validation needed as this is a purely internal class\n        log.debug(\n            'Initialize BacktestInstance for instruments %o',\n            formatInstruments(Array.from(instruments.instruments.values)),\n        );\n        this.instruments = instruments;\n        this.algorithmStack = algorithmStack;\n        this.config = backtestConfig;\n    }\n\n\n    /**\n    * Sets up the handlers for every instrument and runs through the instruments\n    */\n    async run() {\n\n        // Set backtest on every strategy provided\n        await executeAlgorithmsSerially(\n            this.algorithmStack,\n            'setBacktest',\n            [this],\n            true,\n        );\n\n        this.instruments.on('newInstrument', async(instrument) => {\n            await executeAlgorithmsSerially(\n                this.algorithmStack,\n                'handleNewInstrument',\n                [instrument],\n                true,\n            );\n        });\n\n        this.instruments.on('close', async(instruments) => {\n            const date = instruments.length && instruments[0].head().get('date');\n            log.info(\n                '\\n%s - - - - - - - - - - - -  CLOSE %s ',\n                formatInstruments(instruments),\n                formatDate(date),\n            );\n            // Update position values before getting orders – we want the accounts (e.g. invested)\n            // be up to date when we access them in our orders algos.\n            this.updatePositionValues(instruments);\n            const orders = await executeAlgorithmsSerially(\n                this.algorithmStack,\n                'handleClose',\n                [new Map(), instruments],\n                true,\n                true,\n            );\n            // Validate before logging (we need valid orders to log them!)\n            this.validateOrders(orders);\n            log.info(\n                '%s Orders returned by algos are %s',\n                formatDate(date),\n                formatOrders(orders),\n            );\n            this.setOrders(orders);\n        });\n\n        this.instruments.on('open', (instruments) => {\n            const date = instruments.length && instruments[0].head().get('date');\n            log.info(\n                '\\n%s - - - - - - - - - - - -  OPEN %s',\n                formatDate(date),\n                formatInstruments(instruments),\n            );\n            this.executeOrders(instruments);\n        });\n\n        await this.instruments.run();\n\n    }\n\n\n    /**\n     * When orders are created on handleClose of a runner, they must be passed to backtest to be\n     * executed.\n     * @param {Map} orders    Orders to execute\n     * @private\n     */\n    setOrders(orders) {\n        this.orders = orders;\n    }\n\n\n    /**\n    * Checks if the orders array contains valid entries\n    * @param {Map} orders         Orders to check; a Map with key: instrument and value: object\n    *                             with properties size and instrument\n    * @private\n    */\n    validateOrders(orders) {\n\n        // Orders is not a Map\n        if (!(orders instanceof Map)) {\n            throw new Error(`BacktestInstance: orders returned is not a Map but ${JSON.stringify(orders)}`);\n        }\n\n        // Every order needs an instrument and a valid size\n        for (const [instrument, order] of orders) {\n            if (!(instrument instanceof Instrument)) {\n                throw new Error(`BacktestInstance: Every order's key must be an instance of Instrument, is ${JSON.stringify(instrument)} instead.`);\n            }\n\n            if (!Object.prototype.hasOwnProperty.call(order, 'size')) {\n                throw new Error(`BacktestInstance: Every order must have an size property; your order is ${JSON.stringify(order)} instead.`);\n            }\n\n            if (typeof order.size !== 'number') {\n                throw new Error(`BacktestInstance: Every order's size property must be a number; your size is ${JSON.stringify(order.size)} instead.`);\n            }\n        }\n\n    }\n\n\n    /**\n     * Handles afterClose: calculates value of positions depending on close value\n     * @param  {Instrument[]} data      Instruments that were closed\n     * @private\n     */\n    updatePositionValues(instruments) {\n\n        const currentDate = instruments[0].head().get('date');\n        const prices = this.getCurrentPrices(instruments, 'close');\n\n        // Make sure we only calculate values of acutal positions (and not the date or type field\n        // that are also part of this.positions)\n        const updatedPositions = calculatePositionsValues(\n            this.positions.getPositions(this.positions.head()),\n            prices,\n        );\n\n        // Update account\n        const newInvestedValue = Array\n            .from(updatedPositions.values())\n            .reduce((prev, position) => prev + position.value, 0);\n        this.accounts.add(new Map([\n            ['date', currentDate],\n            ['type', 'close'],\n            // Cash doesn't change, we're not trading on close\n            ['cash', this.accounts.head().get('cash')],\n            ['invested', newInvestedValue],\n        ]));\n\n        // Only update positions after we have calculated our new values\n        updatedPositions.set('date', currentDate);\n        updatedPositions.set('type', 'close');\n\n        log.info(\n            '%s Updated positions values after close are %s',\n            formatDate(currentDate),\n            formatPositions(updatedPositions),\n        );\n        log.info(\n            '%s Account: cash %d, invested %d, total %d',\n            formatDate(currentDate),\n            this.accounts.head().get('cash'),\n            this.accounts.head().get('invested'),\n            this.accounts.head().get('cash') + this.accounts.head().get('invested'),\n        );\n\n        // Always update positions, even if they're empty. Add a new row with field type set to\n        // 'close'\n        this.positions.add(updatedPositions);\n    }\n\n\n    /**\n    * Handles the open event of an instrument, executes orders\n    * @param {Instrument[]} instruments       Array of instruments that were just opened. Access\n    *                                         value via instrument.head().get('open')\n    * @private\n    */\n    executeOrders(instruments) {\n\n        const currentDate = instruments[0].head().get('date');\n        log.info(\n            '%s Execute orders %s; instruments with data are %s',\n            formatDate(currentDate),\n            formatOrders(this.orders),\n            formatInstruments(instruments),\n        );\n\n        const prices = this.getCurrentPrices(instruments, 'open');\n\n        // Update all positions values\n        const recalculatedPositions = calculatePositionsValues(\n            this.positions.getPositions(this.positions.head()),\n            prices,\n        );\n\n        const account = this.accounts.head() || this.createAccount();\n        const newPositions = executeOrders(\n            recalculatedPositions,\n            this.orders,\n            prices,\n            account.get('cash'),\n        );\n        log.info(\n            '%s Old positions were %s, new are',\n            formatDate(currentDate),\n            formatPositions(this.positions.head() || new Map()),\n            formatPositions(newPositions),\n        );\n\n\n        // Get values to update account\n        // previousValue is the value of all positions (on afterOpen) before any new positions were\n        // opened\n        const previousValue = Array.from(recalculatedPositions.values())\n            .reduce((prev, position) => prev + position.value, 0);\n        const newInvested = Array.from(newPositions.values())\n            .reduce((prev, position) => prev + position.value, 0);\n\n        // Cash gain/loss is the difference between the value of all positions before and after\n        // we trade\n        const newCash = account.get('cash') + (previousValue - newInvested);\n        const newAccountValues = new Map([\n            ['date', currentDate],\n            ['type', 'open'],\n            ['cash', newCash],\n            ['invested', newInvested],\n        ]);\n        log.info(\n            '%s Account: cash %d, invested %d, total %d',\n            formatDate(currentDate),\n            newCash,\n            newInvested,\n            newCash + newInvested,\n        );\n\n        this.accounts.add(newAccountValues);\n\n        // Always add positions, even if they're empty. Update newPositions only after we have\n        // calculated values for cash & co (or the new properties will also be looped through).\n        newPositions.set('date', currentDate);\n        newPositions.set('type', 'open');\n        this.positions.add(newPositions);\n\n        // Delete all orders – they're good for 1 bar only\n        this.setOrders(new Map());\n\n    }\n\n\n    /**\n     * Calculate this instance's performance index results for every performance index passed\n     * (see Backtest)\n     * @param  {object[]} indicators Indicators to execute; has two methods:\n     *                               - calculate()\n     *                               - getName()\n     * TODO: Write test case!\n     */\n    async calculatePerformanceIndicators(indicators) {\n        for (const indicator of indicators) {\n            const result = await indicator.calculate(this);\n            this.performanceResults.set(indicator.getName(), result);\n        }\n    }\n\n\n    /**\n     * Gets most current prices for all instruments passed and returns them in a map (key:\n     * instrument, value: price)\n     * @param  {array} instrument   Instruments to get prices from\n     * @param  {string} type        Kind of price to get, either 'open' or 'close'\n     * @return {Map}\n     * @private\n     */\n    getCurrentPrices(instruments, type) {\n        return instruments.reduce((prev, instrument) => {\n            prev.set(instrument, instrument.head().get(type));\n            return prev;\n        }, new Map());\n    }\n\n\n    /**\n     * Creates (initial) account entry\n     */\n    createAccount() {\n        return new Map([\n            ['cash', (this.config && this.config.get('cash')) || 0],\n            ['invested', 0],\n        ]);\n    }\n\n}\n\n"],"file":"BacktestInstance.mjs"}