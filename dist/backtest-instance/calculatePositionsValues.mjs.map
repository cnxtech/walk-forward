{"version":3,"sources":["../../src/backtest-instance/calculatePositionsValues.mjs"],"names":["calculatePositionValue","logger","debug","calculatePositionsValues","positions","prices","newPositions","Map","forEach","position","instrument","subPositions","map","subPosition","clonedSubPosition","has","value","get","openPrice","size","set","reduce","prev","subPos","Object","prototype","hasOwnProperty","call","closedPositions"],"mappings":";;;;AAAA,OAAOA,sBAAP,MAAmC,0BAAnC;AACA,OAAOC,MAAP,MAAmB,kBAAnB;AAEA,MAAM;AAAEC,EAAAA;AAAF,IAAYD,MAAM,CAAC,sCAAD,CAAxB;AAEA;;;;;;;;AAOA,eAAe,SAASE,wBAAT,CAAkCC,SAAlC,EAA6CC,MAA7C,EAAqD;AAEhE,QAAMC,YAAY,GAAG,IAAIC,GAAJ,EAArB;AACAH,EAAAA,SAAS,CAACI,OAAV,CAAkB,CAACC,QAAD,EAAWC,UAAX,KAA0B;AAExC,UAAMC,YAAY,GAAGF,QAAQ,CAACL,SAAT,CAAmBQ,GAAnB,CAAwBC,WAAD,IAAiB;AACzD,YAAMC,iBAAiB,qBAAQD,WAAR,CAAvB,CADyD,CAEzD;;;AACA,UAAIR,MAAM,CAACU,GAAP,CAAWL,UAAX,CAAJ,EAA4B;AACxBI,QAAAA,iBAAiB,CAACE,KAAlB,GAA0BhB,sBAAsB,CAC5CK,MAAM,CAACY,GAAP,CAAWP,UAAX,CAD4C,EAE5CG,WAAW,CAACK,SAFgC,EAG5CL,WAAW,CAACM,IAHgC,CAAhD;AAKH;;AACD,aAAOL,iBAAP;AACH,KAXoB,CAArB;AAaAZ,IAAAA,KAAK,CAAC,yBAAD,EAA4BS,YAA5B,CAAL;AAEAL,IAAAA,YAAY,CAACc,GAAb,CAAiBV,UAAjB,EAA6B;AACzBM,MAAAA,KAAK,EAAEL,YAAY,CAACU,MAAb,CAAoB,CAACC,IAAD,EAAOC,MAAP,KAAkBD,IAAI,GAAGC,MAAM,CAACP,KAApD,EAA2D,CAA3D,CADkB;AAEzBG,MAAAA,IAAI,EAAEV,QAAQ,CAACU,IAFU;AAGzBf,MAAAA,SAAS,EAAEO;AAHc,KAA7B,EAjBwC,CAuBxC;;AACA,QAAIa,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqClB,QAArC,EAA+C,iBAA/C,CAAJ,EAAuE;AACnEH,MAAAA,YAAY,CAACW,GAAb,CAAiBP,UAAjB,EAA6BkB,eAA7B,GAA+CnB,QAAQ,CAACmB,eAAxD;AACH;AAEJ,GA5BD;AA8BA,SAAOtB,YAAP;AAEH","sourcesContent":["import calculatePositionValue from './calculatePositionValue';\nimport logger from '../logger/logger';\n\nconst { debug } = logger('WalkForward:calculatePositionsValues');\n\n/**\n * Calculates current values for all positions passed. Positions is the object as used in\n * BacktestInstanceRunner.\n * @param  {Map} positions      Current positions (key is instrument, value a position object)\n * @param  {Map} prices         Current prices (key is instrument, value is price)\n * @return {Map}\n */\nexport default function calculatePositionsValues(positions, prices) {\n\n    const newPositions = new Map();\n    positions.forEach((position, instrument) => {\n\n        const subPositions = position.positions.map((subPosition) => {\n            const clonedSubPosition = { ...subPosition };\n            // If no price is available, position is unchanged\n            if (prices.has(instrument)) {\n                clonedSubPosition.value = calculatePositionValue(\n                    prices.get(instrument),\n                    subPosition.openPrice,\n                    subPosition.size,\n                );\n            }\n            return clonedSubPosition;\n        });\n\n        debug('new subPositions are %o', subPositions);\n\n        newPositions.set(instrument, {\n            value: subPositions.reduce((prev, subPos) => prev + subPos.value, 0),\n            size: position.size,\n            positions: subPositions,\n        });\n\n        // Preserve closedPositions, but only if they exist\n        if (Object.prototype.hasOwnProperty.call(position, 'closedPositions')) {\n            newPositions.get(instrument).closedPositions = position.closedPositions;\n        }\n\n    });\n\n    return newPositions;\n\n}\n"],"file":"calculatePositionsValues.mjs"}