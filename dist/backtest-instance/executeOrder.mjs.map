{"version":3,"sources":["../../src/backtest-instance/executeOrder.mjs"],"names":["calculatePositionValue","logger","debug","defaultPosition","size","value","positions","executeOrder","orderSize","currentPosition","price","newPositionSize","newPositionValue","openPrice","newPositions","closedPositions","outstandingOrderSize","gainRealized","forEach","position","Math","abs","push","gain","currentClosedPositions","reduce","prev","item"],"mappings":"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","sourcesContent":["import calculatePositionValue from './calculatePositionValue';\nimport logger from '../logger/logger';\n\nconst { debug } = logger('WalkForward:executeOrder');\n\nconst defaultPosition = {\n    size: 0,\n    value: 0,\n    positions: [],\n};\n\n/**\n * PLEASE READ FIRST:\n * Executes a single order (converts order to position). MAKE SURE that the price of all\n * currentPisitions is up to date (and corresponds to price). Does NOT test if enough cash or\n * data for price is available – do that somewhere else. The PRICE of the order is the DIFFERENCE\n * between the old and new value.\n *\n * @param {number} orderSize                    Order size; negative for short/sell, positive for\n *                                              buy/cover.\n * @param {object} currentPosition              Current positions of instrument that we're holding\n * @param {number} currentPosition.size         Size of all positions we're currently holding\n * @param {object[]} currentPosition.positions  Positions we're holding; each with size, value,\n *                                              openPrice\n * @param {number} price                        Current instrument's price\n */\nexport default function executeOrder(orderSize, currentPosition = defaultPosition, price) {\n\n    // Same direction (or no existing positions), enlarge position\n    if (orderSize * currentPosition.size >= 0) {\n\n        const newPositionSize = currentPosition.size + orderSize;\n        const value = calculatePositionValue(price, price, orderSize);\n        const newPositionValue = currentPosition.value + value;\n        debug(\n            'Position gets bigger, from %d to %d; position value is %d, total value %d',\n            currentPosition.size,\n            newPositionSize,\n            currentPosition.size,\n            value,\n            newPositionValue,\n        );\n\n        return {\n            value: newPositionValue,\n            size: newPositionSize,\n            positions: [...currentPosition.positions, {\n                size: orderSize,\n                value,\n                openPrice: price,\n            }],\n        };\n    }\n\n    // Order goes in the *other* direction than we're holding – reduce existing positions and add an\n    // additional position if needed\n    else {\n\n        // Clone positions, don't reference anything\n        const newPositions = [];\n\n        // We need closed positions to calculate a strategy's KPIs (e.g. profit factor)\n        const closedPositions = [];\n\n        // We close position by position – reduce outstandingOrderSize by the corresponding amount\n        // until we reach 0\n        let outstandingOrderSize = orderSize;\n\n        // When selling positions, add gain to gainRealized\n        let gainRealized = 0;\n\n        // Reduce current positions until orderSize is reached; if it's not reached by reducing\n        // existing positions, create a new position\n        currentPosition.positions.forEach((position) => {\n\n            // Position is larger than outstanding order: Just reduce; if outstandingOrderSize is\n            // 0, position is just added to newPositions (unchanged)\n            // No need to observe leading signs, we're going in the opposite direction\n            if (Math.abs(position.size) > Math.abs(outstandingOrderSize)) {\n                // Just add order size – we checked above if orderSize < position\n                const newPositionSize = position.size + outstandingOrderSize;\n                const newPositionValue = calculatePositionValue(\n                    price,\n                    position.openPrice,\n                    newPositionSize,\n                );\n                debug(\n                    'Reduce size of position %o to %d; remaining value is %d',\n                    position,\n                    newPositionSize,\n                    newPositionValue,\n                );\n                newPositions.push({\n                    size: newPositionSize,\n                    value: newPositionValue,\n                    openPrice: position.openPrice, // Keep the old openig price\n                });\n\n                // If order size !== 0, add reduced position to closingPositions\n                if (outstandingOrderSize !== 0) {\n                    closedPositions.push({\n                        size: outstandingOrderSize * -1,\n                        value: calculatePositionValue(\n                            price,\n                            position.openPrice,\n                            outstandingOrderSize * -1,\n                        ),\n                        openPrice: position.openPrice,\n                    });\n                }\n\n                // Calculate gain of this trade (remember: we're selling/reducing size)\n                const gain = position.value - newPositionValue;\n                gainRealized += gain;\n                outstandingOrderSize -= (newPositionSize - position.size);\n                debug(\n                    'Realized a gain of %d, outstanding orders are still %d; total gain is %d',\n                    gain,\n                    outstandingOrderSize,\n                    gainRealized,\n                );\n            }\n            // Same size or position is smaller than order: dump it\n            else {\n                outstandingOrderSize += position.size;\n                gainRealized += position.value;\n                closedPositions.push({ ...position });\n                debug('Dump position %o', position);\n            }\n\n        });\n\n        // There's still more that needs to be done to fulfill the order (reducing existing\n        // positions was not enough)\n        if (outstandingOrderSize !== 0) {\n            newPositions.push({\n                size: outstandingOrderSize,\n                value: calculatePositionValue(price, price, outstandingOrderSize),\n                openPrice: price,\n            });\n        }\n\n        debug('New positions are %o', newPositions);\n\n        const currentClosedPositions = currentPosition.closedPositions || [];\n        return {\n            // Re-caulcate position size and value – just to be sure\n            size: newPositions.reduce((prev, item) => prev + item.size, 0),\n            value: newPositions.reduce((prev, item) => prev + item.value, 0),\n            positions: newPositions,\n            closedPositions: [...currentClosedPositions, ...closedPositions],\n        };\n\n    }\n\n}\n\n\n"],"file":"executeOrder.mjs"}