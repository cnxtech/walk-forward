{"version":3,"sources":["../../src/backtest/Backtest.mjs"],"names":["colors","logger","BacktestInstruments","BacktestInstance","Optimization","BacktestExporter","backtestConfigTemplate","validateBacktestConfig","log","debug","Backtest","Map","setConfiguration","backtestConfig","configuration","addPerformanceIndicators","indicators","forEach","indicator","calculate","Error","getName","performanceIndicators","push","setDataSource","source","dataSource","generate","setStrategy","callback","strategyFunction","addOptimization","name","bounds","steps","optimization","addParameter","run","hasOptimizations","parameterConfigs","size","parameterSets","generateParameterSets","undefined","info","length","parameterSet","instruments","bind","get","parameterizedStrategyRunner","Array","isArray","instance","calculatePerformanceIndicators","instances","set","save","path","exporter","export"],"mappings":"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","sourcesContent":["import colors from 'colors';\nimport logger from '../logger/logger';\nimport BacktestInstruments from '../backtest-instruments/BacktestInstruments.mjs';\nimport BacktestInstance from '../backtest-instance/BacktestInstance.mjs';\nimport Optimization from '../optimization/Optimization.mjs';\nimport BacktestExporter from '../backtest-exporter/BacktestExporter.mjs';\nimport backtestConfigTemplate from '../backtest-config/backtestConfigTemplate.mjs';\nimport validateBacktestConfig from '../backtest-config/validateBacktestConfig.mjs';\n\nconst log = logger('WalkForward:Backtest');\nconst { debug } = log;\n\n/**\n* The main class which holds most functionality.\n*/\nexport default class Backtest {\n\n    /**\n    * Strategies to backtest, wrapped in a function (which takes the optimization params as\n    * an argument)\n    * @private\n    */\n    strategyFunction;\n\n    /**\n    * Source to read data from\n    * @private\n    */\n    dataSource;\n\n    /**\n     * Holds performance indicators that should be applied to all backtestInstances\n     * @private\n     */\n    performanceIndicators = [];\n\n    /**\n     * Holds backtest instances. Key is the parameter set used (, value the corresponding\n     * BacktestInstance\n     * @private\n     */\n    instances = new Map();\n\n    /**\n    * Backtest facades Optimization â€“ this.optimization holds the corresponding instance\n    * @private\n    */\n    optimization = new Optimization();\n\n    /**\n    * Sets configuration for backtest (commissions, initial cash etc.)\n    * @param {Map<string, function>} backtestConfig     Configuration for the backtest; valid keys\n    *                                                   are:\n    *                                                   - cash (initial amount on cash account)\n    */\n    setConfiguration(backtestConfig) {\n        this.configuration = validateBacktestConfig(backtestConfig, backtestConfigTemplate);\n    }\n\n    /**\n     * Adds a performance indicator that will be applied to every backtestInstance\n     * @param {object[]} indicators         An array containing objects with properties:\n     *                                      - name: Name of the performance indicator\n     *                                      - indicator: Indicator to execute, is an object with a\n     *                                        method 'calculate' that takes a backtestInstance as an\n     *                                        argument and returns the performance index's value\n     */\n    addPerformanceIndicators(...indicators) {\n        indicators.forEach((indicator) => {\n            if (!indicator.calculate || typeof indicator.calculate !== 'function') {\n                throw new Error(`Backtest: Perofmance indicator provided does not contain a calculate method, calculated is ${indicator.calculate} instead.`);\n            }\n            if (!indicator.getName || typeof indicator.getName !== 'function' || typeof indicator.getName() !== 'string') {\n                throw new Error(`Backtest: Performance indicator must have a getName method that returns the performance indicator's name (string), is ${indicator.getName}.`);\n            }\n            this.performanceIndicators.push(indicator);\n        });\n    }\n\n\n    /**\n    * Define a data source; this might only be done once. DataSource must have a read method\n    * which returns a promise that resolves to the data available (see CSVSource and\n    * BacktestCSVSource).\n    * @param {class} source             Source to add\n    * @param {function} source.read\n    */\n    setDataSource(source) {\n\n        if (this.dataSource) {\n            throw new Error('Backtest: You can only use the setDataSource method once; once your data source is set, you cannot change it.');\n        }\n\n        if (!source || typeof source.generate !== 'function') {\n            throw new Error('Backtest: When using setSource, pass an object (instance) that has a generate method.');\n        }\n\n        this.dataSource = source;\n\n    }\n\n\n    /**\n    * Defines the strategies to backtest\n    * @param {function} callback        Callback that will be invoked when backtest is run;\n    *                                   arguments are values (one instance for every combination\n    *                                   of the optimizations provided)\n    */\n    setStrategy(callback) {\n        if (typeof callback !== 'function') {\n            throw new Error('Backtest: Method setStrategies only accepts a function which will be called with the current optimization parameters');\n        }\n        this.strategyFunction = callback;\n    }\n\n\n    /**\n    * Adds a param that will be optimized. The default optimization type is logarithmic.\n    * @param {string} name          Name of the optimized parameter\n    * @param {number[]} bounds      Array with two numbers: from and to\n    * @param {integer} steps        Number of steps optimized parameter should take from {from}\n    *                               to {to}\n    */\n    addOptimization(name, bounds, steps) {\n        this.optimization.addParameter(name, bounds, steps);\n    }\n\n\n\n    /**\n    * Runs the backtest\n    */\n    async run() {\n\n        // If setConfig was not used, initialize configuration with default values\n        if (!this.configuration) {\n            this.configuration = validateBacktestConfig(new Map(), backtestConfigTemplate);\n        }\n\n        if (!this.strategyFunction) {\n            throw new Error('Backtest: You can only run a backtest after having added one or more strategies. Use the setStrategy() method to do so.');\n        }\n\n        if (!this.dataSource) {\n            throw new Error('Backtest: Data source missing. Use setDataSource(source) method to add a data source before running a backtest, it needs to have a generate() method that is a generator.');\n        }\n\n        const hasOptimizations = !!this.optimization.parameterConfigs.size;\n        const parameterSets = hasOptimizations ? this.optimization.generateParameterSets() :\n            [undefined];\n\n        log.info(`Run backtest for ${parameterSets.length} parameter sets.`);\n        for (const parameterSet of parameterSets) {\n\n            log.info(`Current parameter set is ${parameterSet}.`);\n\n            // Define INSIDE of parameter loop; as a BacktestInstrument emits open/close events,\n            // it must be re-instantiated every single time we run a backtest instance. Caching, if\n            // needed, is done within the data source.\n            const instruments = new BacktestInstruments(\n                this.dataSource.generate.bind(this.dataSource),\n                this.configuration.get('startDate'),\n                this.configuration.get('endDate'),\n            );\n            const parameterizedStrategyRunner = this.strategyFunction(parameterSet);\n\n            if (!Array.isArray(parameterizedStrategyRunner)) {\n                throw new Error(`Backtest: Strategy function must return an array, returned ${parameterizedStrategyRunner} instead.`);\n            }\n\n            const instance = new BacktestInstance(\n                instruments,\n                parameterizedStrategyRunner,\n                this.configuration,\n            );\n            await instance.run();\n            await instance.calculatePerformanceIndicators(this.performanceIndicators);\n\n            this.instances.set(parameterSet, instance);\n        }\n\n        log.info(`${this.instances.size} instances were run successfully.`);\n        return this.instances;\n\n    }\n\n\n\n    /**\n     * Exports the backtest's data to the folder provided\n     * @param {String} path         Path (folder) to export CSVs to. Make sure it exists before\n     *                              calling save().\n     */\n    async save(path) {\n\n        // Don't save before running\n        if (!this.instances || !this.instances.size) {\n            throw new Error('Backtest: You cannot save backtest data before running the backtest. Make sure you call run() first.');\n        }\n        const exporter = new BacktestExporter();\n        await exporter.export(this.instances, path);\n\n    }\n\n\n}\n\n"],"file":"Backtest.mjs"}