{"version":3,"sources":["../../src/awaiting-event-emitter/AwaitingEventEmitter.mjs"],"names":["logger","debug","AwaitingEventEmitter","Map","on","type","callback","checkType","Error","handlers","has","get","push","set","emit","data","callbacks","length"],"mappings":";;AAAA,OAAOA,MAAP,MAAmB,kBAAnB;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAYD,MAAM,CAAC,kCAAD,CAAxB;AAEA,eAAe,MAAME,oBAAN,CAA2B;AAAA;AAAA,sCAE9B,IAAIC,GAAJ,EAF8B;AAAA;;AAIzC;;;;;AAKAC,EAAAA,EAAE,CAACC,IAAD,EAAOC,QAAP,EAAiB;AAClB,SAAKC,SAAL,CAAeF,IAAf;;AACA,QAAI,CAACC,QAAD,IAAa,OAAOA,QAAP,KAAoB,UAArC,EAAiD;AAChD,YAAM,IAAIE,KAAJ,CAAW;mBAAX,CAAN;AAEA;;AAEDP,IAAAA,KAAK,CAAC,6BAAD,EAAgCI,IAAhC,CAAL;AACA,QAAI,KAAKI,QAAL,CAAcC,GAAd,CAAkBL,IAAlB,CAAJ,EAA6B,KAAKI,QAAL,CAAcE,GAAd,CAAkBN,IAAlB,EAAwBO,IAAxB,CAA6BN,QAA7B,EAA7B,KACK,KAAKG,QAAL,CAAcI,GAAd,CAAkBR,IAAlB,EAAwB,CAACC,QAAD,CAAxB;AAEL;AAED;;;;;AAGA,QAAMQ,IAAN,CAAWT,IAAX,EAAiBU,IAAjB,EAAuB;AACtB,SAAKR,SAAL,CAAeF,IAAf;AACAJ,IAAAA,KAAK,CAAC,yCAAD,EAA4CI,IAA5C,EAAkDU,IAAlD,CAAL;AACA,UAAMC,SAAS,GAAG,KAAKP,QAAL,CAAcE,GAAd,CAAkBN,IAAlB,CAAlB;;AACA,QAAI,CAACW,SAAL,EAAgB;AACff,MAAAA,KAAK,CAAC,uCAAD,EAA0CI,IAA1C,CAAL;AACA;AACA;;AACDJ,IAAAA,KAAK,CAAC,kCAAD,EAAqCe,SAAS,CAACC,MAA/C,EAAuDZ,IAAvD,CAAL;;AACA,SAAK,MAAMC,QAAX,IAAuBU,SAAvB,EAAkC;AACjC,YAAMV,QAAQ,CAACS,IAAD,CAAd;AACA;AACD;AAGD;;;;;;AAIAR,EAAAA,SAAS,CAACF,IAAD,EAAO;AACf,QAAI,CAACA,IAAD,IAAS,OAAOA,IAAP,KAAgB,QAA7B,EAAuC;AACtC,YAAM,IAAIG,KAAJ,CAAW;yCAAX,CAAN;AAEA;AACD;;AAjDwC","sourcesContent":["import logger from '../logger/logger';\nconst { debug } = logger('WalkForward:AwaitingEventEmitter');\n\nexport default class AwaitingEventEmitter {\n\n\thandlers = new Map();\n\n\t/**\n\t* Adds an event listener\n\t* @param {string} type\t\t\tType of event to listen to\n\t* @param {function} callback\tCallback to call when event of type type is emitted\n\t*/\n\ton(type, callback) {\n\t\tthis.checkType(type);\n\t\tif (!callback || typeof callback !== 'function') {\n\t\t\tthrow new Error(`AwaitingEventEmitter: Second argument must be a function which handles\n\t\t\t\tthe callbacks.`);\n\t\t}\n\n\t\tdebug('Add handler for type \\'%s\\'', type);\n\t\tif (this.handlers.has(type)) this.handlers.get(type).push(callback);\n\t\telse this.handlers.set(type, [callback]);\n\n\t}\n\n\t/**\n\t* Emit an event, call all its callbacks and wait until they're completed\n\t*/\n\tasync emit(type, data) {\n\t\tthis.checkType(type);\n\t\tdebug('Emit event for type \\'%s\\' with data %o', type, data);\n\t\tconst callbacks = this.handlers.get(type);\n\t\tif (!callbacks) {\n\t\t\tdebug('No handlers available for type \\'%s\\'', type);\n\t\t\treturn;\n\t\t}\n\t\tdebug('Call %d handlers for type \\'%s\\'', callbacks.length, type);\n\t\tfor (const callback of callbacks) {\n\t\t\tawait callback(data);\n\t\t}\n\t}\n\n\n\t/**\n\t* Checks if type passed is a string\n\t* @private\n\t*/\n\tcheckType(type) {\n\t\tif (!type || typeof type !== 'string') {\n\t\t\tthrow new Error(`AwaitingEventEmitter: Pass a string as the first argument to the \n\t\t\t\ton method; it holds the type's name.`);\n\t\t}\n\t}\n\n\n}"],"file":"AwaitingEventEmitter.mjs"}