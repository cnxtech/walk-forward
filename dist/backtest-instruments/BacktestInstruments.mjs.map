{"version":3,"sources":["../../src/backtest-instruments/BacktestInstruments.mjs"],"names":["AwaitingEventEmitter","Instrument","logger","checkInstrumentData","formatDate","log","debug","BacktestInstruments","constructor","generatorFunction","startDate","endDate","Map","Error","Date","run","info","intervalData","forEach","dataSet","currentDate","get","getTime","openedInstruments","openInstruments","emit","closedInstruments","closeInstruments","instrumentsData","Promise","all","map","instrumentData","instrument","getOrCreateInstrument","add","cleanedMap","field","delete","set","name","existingInstrument","instruments"],"mappings":"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","sourcesContent":["import AwaitingEventEmitter from '../awaiting-event-emitter/AwaitingEventEmitter';\nimport Instrument from '../instrument/Instrument';\nimport logger from '../logger/logger';\nimport checkInstrumentData from '../helpers/checkInstrumentData';\nimport { formatDate } from '../helpers/formatLogs';\n\nconst log = logger('WalkForward:BacktestInstruments');\nconst { debug } = log;\n\n/**\n * Converts data from a fitting data source to instruments and emits events for 'close', 'open' and\n * 'newInstrument'. Will be consumed by new Backtest().run()\n*/\nexport default class BacktestInstruments extends AwaitingEventEmitter {\n\n    /**\n     * Holds all instruments for the current backtest. Key: name, value: instance of Instrument.\n     * @private\n     */\n    instruments = new Map();\n\n\n    /**\n     * @param {function} generatorFunction  An async generator function that returns data (for a\n     *                                       whole interval, e.g. day) whenever it is ready; see\n     *                                       e.g. BacktestCSVSource.\n     */\n    constructor(generatorFunction, startDate, endDate) {\n        super();\n        if (typeof generatorFunction !== 'function') {\n            throw new Error(`BacktestInstruments: Provide a generator function as first argument, type provided is ${typeof generatorFunction}.`);\n        }\n        if (startDate && !(startDate instanceof Date)) {\n            throw new Error(`BacktestInstruments: if startDate is provided, it must be a Date, is ${startDate}.`);\n        }\n        if (endDate && !(endDate instanceof Date)) {\n            throw new Error(`BacktestInstruments: if endDate is provided, it must be a Date, is ${endDate}.`);\n        }\n        this.generatorFunction = generatorFunction;\n        this.startDate = startDate;\n        this.endDate = endDate;\n    }\n\n\n    /**\n     * Runs the async generator until it's all done. Creates instruments out of the data received\n     * and emits a data event on every iteration, then awaits completion of the registered handlers.\n     */\n    async run() {\n        log.info('Run instruments');\n        for await (const intervalData of this.generatorFunction()) {\n            // Check all generated data for its validity\n            intervalData.forEach(dataSet => checkInstrumentData(dataSet));\n\n            // Only emit if current startDate < intervalData < endDate\n            const currentDate = intervalData[0].get('date');\n            if (this.startDate && this.startDate.getTime() > currentDate.getTime()) continue;\n            if (this.endDate && this.endDate.getTime() < currentDate.getTime()) continue;\n\n            // Open: Create instrument, add open and date\n            const openedInstruments = await this.openInstruments(intervalData);\n            log.info('%s Emit open', formatDate(currentDate));\n            await this.emit('open', openedInstruments);\n\n            // Close\n            const closedInstruments = await this.closeInstruments(intervalData);\n            log.info('%s Emit close', formatDate(currentDate));\n            await this.emit('close', closedInstruments);\n        }\n    }\n\n\n    /**\n     * Converts instrument data to instances of Instrument, sets date and open properties on them,\n     * then returns the updated Instruments\n     * @param {Map[]} instrumentsData   Data for instruments that were opened (Map with keys for\n     *                                  name, date, open â€¦)\n     * @return {Instrument[]}           Created or updated instruments\n     * @private\n     */\n    async openInstruments(instrumentsData) {\n        return Promise.all(instrumentsData.map(async(instrumentData) => {\n            const instrument = await this.getOrCreateInstrument(instrumentData.get('instrument'));\n            await instrument.add(new Map([\n                ['date', instrumentData.get('date')],\n                ['open', instrumentData.get('open')],\n            ]));\n            return instrument;\n        }));\n    }\n\n\n    /**\n     * Adds all other fields than name, open and date to the Instrument that matches instrumentData\n     * and returns all affected Instruments as an array.\n     * @param  {Map[]} instrumentsData  Data for all instruments that were closed\n     * @return {Instrument[]}           Instances of Instrument with updated fields for the\n     *                                  instrumentsData that was passed\n     */\n    async closeInstruments(instrumentsData) {\n        return Promise.all(instrumentsData.map(async(instrumentData) => {\n            const instrument = await this.getOrCreateInstrument(instrumentData.get('instrument'));\n            // Delete fields that were already added to instrument from (a clone of) instrumentData\n            const cleanedMap = new Map(instrumentData);\n            ['open', 'instrument', 'date'].forEach(field => cleanedMap.delete(field));\n            await instrument.set(cleanedMap);\n            return instrument;\n        }));\n    }\n\n\n    /**\n    * Returns an instrument from this.instruments if it was found, else creates it.\n    * @private\n    * @param {string} name          Instrument's name\n    */\n    async getOrCreateInstrument(name) {\n        const existingInstrument = this.instruments.get(name);\n        if (existingInstrument) return existingInstrument;\n        else {\n            debug('Create new instrument %o, emit newInstrument', name);\n            const instrument = new Instrument(name);\n            this.instruments.set(name, instrument);\n            await this.emit('newInstrument', instrument);\n            return instrument;\n        }\n    }\n\n}\n"],"file":"BacktestInstruments.mjs"}